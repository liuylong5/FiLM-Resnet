!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of getalpha in reverse (adjoint) mode:
!   gradient     of useful results: alfa0 alfa2 alfa3
!   with respect to varying inputs: clconst esgc16 esgc4 defl2sg
!                maxl2sg minl2sg massi numi surfi
!
!***********************************************************************
!   Portions of Models-3/CMAQ software were developed or based on      *
!   information from various groups: Federal Government employees,     *
!   contractors working on a United States Government contract, and    *
!   non-Federal sources (including research institutions).  These      *
!   research institutions have given the Government permission to      *
!   use, prepare derivative works, and distribute copies of their      *
!   work in Models-3/CMAQ to the public and to permit others to do     *
!   so.  EPA therefore grants similar permissions for use of the       *
!   Models-3/CMAQ software, but users are requested to provide copies  *
!   of derivative works to the Government without restrictions as to   *
!   use by others.  Users are responsible for acquiring their own      *
!   copies of commercial software associated with Models-3/CMAQ and    *
!   for complying with vendor requirements.  Software copyrights by    *
!   the MCNC Environmental Modeling Center are used with their         *
!   permissions subject to the above restrictions.                     *
!***********************************************************************
!
! RCS file, release, date & time of last delta, author, state, [and locker]
! $Header$
!
! what(1) key, module and SID; SCCS file; date and time of last delta:
! %W% %P% %G% %U%
!
!:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      SUBROUTINE GETALPHA_B(numi, numib, massi, massib, surfi, surfib, lwc, t
     +  , p, rhoair, alfa0, alfa0b, alfa2, alfa2b, alfa3, alfa3b)
        USE AERO_DATA
        IMPLICIT NONE
!
!...........Statement Functions:
!
!
!-----------------------------------------------------------------------
!  Description:
!    Calculate the in-cloud scavenging coefficients for number (alfa0),
!    surface area (alfa2) and mass (alfa3). This code combines the RPM
!    codes getcld.f, and pandkcd.f
!  Revision History:
!      Date       Who                      What
!    -------- -------------------------  -------------------------------
!    12/16/97 Dr. Francis S. Binkowski.  Coded
!    12/22/97 S.Roselle                  Revised to comply with M3 Coding
!                                           standards
!    02/10/99 Binkowski                  Added provision for 2nd moment
!                                           and variable geometric
!                                           standard deviation
!    09/25/00 S.Roselle                  Modified to enable backwards
!                                           compatibility with aerosol
!                                           model version 1
!    08/23/2005  Binkowski               Changed check on MASSI to
!                                           be 1.0e-6 [ug/M**3] rather than
!                                           to avoid difficulties causing NAN's
!                                           as found by Bonyoung Koo
!                                           I have also commented out some lines
!                                           code that are unnecessary in this
!                                           implementation
!-----------------------------------------------------------------------
!
!
!...........Parameters:
!
! geometric standard deviation for cloud droplets
        REAL, PARAMETER :: sigc=1.2
!
! Standard pressure [ Pa ]
        REAL, PARAMETER :: p0=101325.0
!
        REAL, PARAMETER :: t0=288.0
!
        REAL, PARAMETER :: pi=3.14159265
!
        REAL, PARAMETER :: one3=1.0/3.0
!
        REAL, PARAMETER :: two3=2.0/3.0
!
! [ J/K ]
        REAL, PARAMETER :: kboltz=1.38066e-23
!
! particle density [ kg/ m**3 ]
        REAL, PARAMETER :: rhopart=1.0e3
!
!sjr  REAL, PARAMETER :: AERCONST = 6.0E-9 / ( RHOPART * PI / 6.0 )
        REAL, PARAMETER :: aerconst=1.0e-9/(rhopart*pi/6.0)
!
! [ m/s**2 ]
        REAL, PARAMETER :: grav=9.8
!
! density of water at 20 C & 1 ATM [ kg/m**3 ]
        REAL, PARAMETER :: rho_water=1.0e3
!
!...........Arguments:
!
! total number concentration for the Aitken mode [ #/m**3 ]
        REAL :: numi
        REAL :: numib
! total mass concentration in AItken mode [ ug/m**3 ]
        REAL :: massi
        REAL :: massib
! total surface area in Aitken mode [ m**2 / m**3 ]
        REAL :: surfi
        REAL :: surfib
! cloud liquid water content [ kg/m**3 ]
        REAL :: lwc
! average cloud temperature [ K ]
        REAL :: t
! average cloud pressure [ Pa ]
        REAL :: p
! average cloud density [ kg/m**3 ]
        REAL :: rhoair
! scavenging coefficient for number [ 1/s ]
        REAL :: alfa0
        REAL :: alfa0b
! scavenging coefficient for surface area [ 1/s ]
        REAL :: alfa2
        REAL :: alfa2b
! scavenging coefficient for mass [ 1/s ]
        REAL :: alfa3
        REAL :: alfa3b
!
!...........Local Variables (scalars):
!
! geometric mean diameter for AItken mode [ m ]
        REAL :: dgni
        REAL :: dgnib
! square of the log of the
! Aitken mode geometric standard deviation
        REAL :: l2sgi
        REAL :: l2sgib
!     REAL          XXFN       ! fraction for computing L2SGI
!
! *** ranges for acceptable values of LOG( sigma_g).
!
! minimum value of L2SG
        REAL, SAVE :: minl2sg
! maximum value of L2SG
        REAL, SAVE :: maxl2sg
! default value of L2SG if no surface area
        REAL, SAVE :: defl2sg
!
! total cloud droplet number concentration  [ #/m**3 ]
        REAL :: nc
! geometric mean diameter for cloud droplet [ m ]
        REAL :: dgc
! exp(0.5 * L2SGI )
        REAL :: esg4
        REAL :: esg4b
! exp(2.0 * L2SGI )
        REAL :: esg16
        REAL :: esg16b
! exp(4.5 * L2SGI )
        REAL :: esg36
        REAL :: esg36b
! square of geometic mean diameter
        REAL :: dg2
! -2nd moment of the Aitken mode distribution
        REAL :: amm2
! -1st moment of the Aitken mode distribution
        REAL :: amm1
! 1st moment of the Aitken mode distribution
        REAL :: am1
        REAL :: am1b
! alternative name for Aitken mode number  [ #/m**3]
        REAL :: am0
        REAL :: am0b
! 2nd moment of the Aitken mode distribution
        REAL :: am2
        REAL :: am2b
! 3rd moment of the Aitken mode distribution
        REAL :: am3
        REAL :: am3b
! moments of the cloud droplet distribution
        REAL :: m0c
! moments of the cloud droplet distribution
        REAL :: m1c
! moments of the cloud droplet distribution
        REAL :: m2c
!
! log and square of log of SIGC
        REAL :: lsgc, lsgc2
!
        REAL, SAVE :: esgc4
!
        REAL, SAVE :: esgc16
!
!
        REAL :: coef
! aerosol diffusivities
        REAL :: diff0
! aerosol diffusivities
        REAL :: diff2
! aerosol diffusivities
        REAL :: diff3
        REAL :: diff3b
! Peclet numbers
        REAL :: pe0
! Peclet numers
        REAL :: pe2
! Peclet numbers
        REAL :: pe3
        REAL :: pe3b
!
        REAL :: coef2
!
        REAL :: coef3
!
        REAL :: coef4
! settling velocity for cloud drops
        REAL :: vsettl
! mean free path of air [ m ]
        REAL :: lamda
! dynamic viscosity [ kg/(m*s) ]
        REAL :: mu
! kinematic viscosity [ m**2/s ]
        REAL :: nu
!
! cube root
        REAL :: cubrt
! dummy arguement for cube root
        REAL :: xx
!
!
        REAL, SAVE :: clconst
!
! flag for first pass thru
        LOGICAL, SAVE :: firstime=.true.
        INTEGER :: branch
        REAL :: temp1
        REAL :: temp0
        REAL :: temp0b
        REAL :: tempb0
        REAL :: tempb
        REAL :: temp1b
        REAL :: temp

	  
	  double precision, parameter :: onedp=1.d0
! check on firstime
!
!-----------------------------------------------------------------------
!     begin body of subroutine GETALPHA
!
        IF (firstime) THEN
	    firstime=.false.
!
!...compute special variables for moments
!...  of cloud droplet distribution
!
          lsgc = LOG(sigc)
          lsgc2 = lsgc*lsgc
          esgc4 = EXP(0.5*lsgc2)
          esgc16 = EXP(2.0*lsgc2)
!
!...compute constant for obtaining dgc
!
          clconst = 6.0/(rho_water*pi*EXP(4.5*LOG(sigc)**2))
!
! minimum sigma_g = 1.05 (2.380480e-3)
          minl2sg = LOG(min_sigma_g)**2.0
! maximum sigma_g = 2.5  (8.395887e-1)
          maxl2sg = LOG(max_sigma_g)**2.0
! default sigma_g = 1.7  (2.815663e-1)
          defl2sg = LOG(def_sigma_g)**2.0
!
        END IF
!
!...check to make sure that there is aerosol mass and number before
!... proceeding, if not set alphas to zero
!
!cc FSB      IF ( ( NUMI .LE. 0.0 ) .OR. ( MASSI .LE. 0.0 ) .OR.
!cc FSB    &     ( LWC  .LE. 0.0 ) ) THEN
!
! FSB mass check changed to be 1.0e-6 [ug/m**3] - 08/23/2005
!     to avoid AM3 becomming too small.  With this change
!     AM3 is no smaller than 1.0e-18
!
        IF ((numi .LE. 0.0 .OR. massi .LE. 1.0e-6) .OR. lwc .LE. 0.0) THEN
          massib = 0.0
          numib = 0.0
          surfib = 0.0
        ELSE
!
!...get cloud characteristics
!...  reference: Bower, K.N. and T.W. Choularton, 1992,
!...  " A parameterisation of the effective radius of ice
!...  free clouds for use in global climate models"
!...  Atmospheric Research, 27, 305-339, figures 10 & 11.
!...
!...  data in Bower & Choularton fit with quadratic function
!...  for droplet number as a function of lwc
!
!...calculate the total number concentration of cloud droplets.
!
          IF (lwc .LE. 3.0e-3) THEN
            nc = 4.80e11*lwc - 8.0e13*lwc*lwc
          ELSE
            nc = 7.20e8
          END IF
!
!...calculate dgc
!
          dgc = EXP(one3*LOG(clconst*lwc/nc))
!
!...get m0c cloud droplet number and 1st and 2nd moments
!...  of cloud droplet distribution
!
          m0c = nc
          m1c = m0c*dgc*esgc4
          m2c = m0c*dgc*dgc*esgc16
!
!...set values for the 0th and 3rd moments
!
          am3 = aerconst*massi
          am0 = numi
!
!...Check to see if surface area exists and process accordingly
!
          IF (surfi .GT. 0.0) THEN
!
!...set the 2nd moment value
!
            am2 = surfi/pi
!
!...get square of the log of the geometric standard deviation L2SGI
!...  The following method is much more robust, even if it uses three log calls.
!
            l2sgi = one3*LOG(am0) + two3*LOG(am3) - LOG(am2)
            IF (minl2sg .LT. l2sgi) THEN
              CALL PUSHINTEGER4(0)
              l2sgi = l2sgi
            ELSE
              l2sgi = minl2sg
              CALL PUSHINTEGER4(1)
            END IF
            IF (maxl2sg .GT. l2sgi) THEN
              CALL PUSHINTEGER4(0)
              l2sgi = l2sgi
            ELSE
              l2sgi = maxl2sg
              CALL PUSHINTEGER4(1)
            END IF
          ELSE
!
!...set the standard deviation to a fixed value (e.g. 1.7)
!
            l2sgi = defl2sg
!
!...calculate the 2nd moment based on the fixed standard deviation
!
            am2 = EXP(two3*LOG(am3) + one3*LOG(am0) - l2sgi)
!
            CALL PUSHINTEGER4(2)
          END IF
!
!...compute special variables for moments
!...  of Aitken mode distribution
!
          esg4 = EXP(0.5*l2sgi)
          esg16 = EXP(2.0*l2sgi)
          esg36 = esg4*esg16*esg16
!
!...calculate dgni from numi and m3i
!
          dgni = EXP(one3*LOG(am3/(am0*esg36)))
!
!...now get other aerosol moments
!
          am1 = am0*dgni*esg4
!
!...calculate:
!...  lamda     mean free path of air [ m ]
!...  mu        dynamic viscosity [ kg/(m*s) ]
!...  nu        kinematic viscosity [ m**2/s ]
!
          mu = 1.458e-6*t*SQRT(t)/(t+110.4)
          lamda = 6.6328e-8*(p0/p)*(t/t0)
          nu = mu/rhoair
!
!...implement Pruppacher and Klett method for scavenging coefficients
!...  calculates scavenging coefficients for number and mass
!...  of interstitial aerosol with a variable sigma_g.
!...  this method uses Brownian diffusion with convective enhancement.
!...  reference:
!...      Pruppacher & Klett "Microphysics of Clouds & Precipitation"
!...                             pp 380 - 384, 1978, D. Reidel
!
          coef = kboltz*(t/(3.0*pi*mu))
!
!...get aerosol diffusivities
!
!cc FSB these values are not used
!cc      DIFF0 = COEF * ( AMM1 + 2.492 * LAMDA * AMM2 ) / AM0
!cc      DIFF2 = COEF * ( AM1  + 2.492 * LAMDA * AM0  ) / AM2
          diff3 = coef*((am2+2.492*lamda*am1)/am3)
!
!...set up coefficient coef2 for settling velocity of cloud drops
!
          coef2 = grav/(18.0*nu)*(rhopart/rhoair)
!
!...get settling velocity for cloud drops
!
          vsettl = coef2*m2c/m0c
!
!...set up for Peclet numbers
!
          coef3 = vsettl*dgc
!
!...calculate Peclet numbers
!
!cc FSB because these Peclet numbers are not used, I have commented
!cc     these lines of code - Binkowski 08/23/2005
!cc      PE0 = COEF3 / DIFF0
!cc      PE2 = COEF3 / DIFF2
          pe3 = coef3/diff3
!
!...now get in-cloud scavenging coefficients
!...  including convective enhancement
!
          coef4 = 2.0*pi*m1c
!
!cc FSB use a common value, that for 3rd moment.
!cc
!cc      ALFA0 = COEF4 * DIFF0 * ( 1.0 + 0.5 * CUBRT( PE0 ) )
!cc      ALFA2 = COEF4 * DIFF2 * ( 1.0 + 0.5 * CUBRT( PE2 ) )
!
          alfa3b = alfa3b + alfa0b + alfa2b
          temp1 = one3*LOG(pe3)
          pe3b = coef4*diff3*0.5*EXP(temp1)*one3*alfa3b/pe3
!sssss          diff3b = coef4*(0.5*EXP(temp1)+1.0)*alfa3b - coef3*pe3b/diff3**2
          diff3b = onedp*coef4*(0.5d0*EXP(temp1)+1.0)*alfa3b - onedp*coef3*pe3b/(onedp*diff3)**2
          temp1b = coef*diff3b/am3
          am2b = temp1b
          am1b = lamda*2.492*temp1b
          dgnib = esg4*am0*am1b
          temp = am0*esg36
          temp0 = am3/temp
!sssss          temp0b = EXP(one3*LOG(temp0))*one3*dgnib/(temp0*temp)
          temp0b = onedp*EXP(one3*LOG(temp0))*one3*dgnib/(temp0*temp)
          am3b = temp0b - (am2+lamda*2.492*am1)*temp1b/am3
          tempb0 = -(temp0*temp0b)
          am0b = esg36*tempb0 + esg4*dgni*am1b
          esg36b = am0*tempb0
          esg4b = esg16**2*esg36b + am0*dgni*am1b
          esg16b = esg4*2*esg16*esg36b
          l2sgib = EXP(0.5*l2sgi)*0.5*esg4b + EXP(2.0*l2sgi)*2.0*esg16b
          CALL POPINTEGER4(branch)
          IF (branch .LT. 2) THEN
            IF (.NOT.branch .LT. 1) l2sgib = 0.0
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 1) l2sgib = 0.0
            am0b = am0b + one3*l2sgib/am0
            am3b = am3b + two3*l2sgib/am3
            am2b = am2b - l2sgib/am2
            surfib = am2b/pi
          ELSE
            tempb = EXP(two3*LOG(am3)-l2sgi+one3*LOG(am0))*am2b
            am3b = am3b + two3*tempb/am3
            am0b = am0b + one3*tempb/am0
            surfib = 0.0
          END IF
          numib = am0b
          massib = aerconst*am3b
        END IF
      END SUBROUTINE GETALPHA_B
