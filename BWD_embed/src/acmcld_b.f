!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of acmcld in reverse (adjoint) mode:
!   gradient     of useful results: cbelow c
!   with respect to varying inputs: cbelow c
!
!***********************************************************************
!   Portions of Models-3/CMAQ software were developed or based on      *
!   information from various groups: Federal Government employees,     *
!   contractors working on a United States Government contract, and    *
!   non-Federal sources (including research institutions).  These      *
!   research institutions have given the Government permission to      *
!   use, prepare derivative works, and distribute copies of their      *
!   work in Models-3/CMAQ to the public and to permit others to do     *
!   so.  EPA therefore grants similar permissions for use of the       *
!   Models-3/CMAQ software, but users are requested to provide copies  *
!   of derivative works to the Government without restrictions as to   *
!   use by others.  Users are responsible for acquiring their own      *
!   copies of commercial software associated with Models-3/CMAQ and    *
!   for complying with vendor requirements.  Software copyrights by    *
!   the MCNC Environmental Modeling Center are used with their         *
!   permissions subject to the above restrictions.                     *
!***********************************************************************
!
! RCS file, release, date & time of last delta, author, state, [and locker]
! $Header: /project/work/rep/CCTM/src/cloud/cloud_acm_ae5/acmcld.f,v 1.4 2008/09/03 15:55:53 sjr Exp $
!
! what(1) key, module and SID; SCCS file; date and time of last delta:
! %W% %P% %G% %U%
!
!:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      SUBROUTINE ACMCLD_B(f, c, cb, sigmaf, cbelow, cbelowb, clbase, cltop,
     +  frac, nsp, nlays, tclife, dtcld)
        IMPLICIT NONE
!
! Arguments
!
! no. of species
        INTEGER :: nsp
! no. of model layers
        INTEGER :: nlays
! entrainment fraction
        REAL :: f(nlays)
! species concentration
        REAL :: c(nsp, nlays)
        REAL :: cb(nsp, nlays)
! full layer sigma (mono decr)
        REAL :: sigmaf(0:nlays)
! spec conc in layer below cld base
        REAL :: cbelow(nsp)
        REAL :: cbelowb(nsp)
        INTEGER :: clbase, cltop
! grid cell fractional cloud cover
        REAL :: frac
! cloud lifetime (s)
        REAL :: tclife
! cloud integration time step
        REAL :: dtcld
!
! Parameters
!
        REAL, PARAMETER :: half=0.5
        REAL, PARAMETER :: crankp=0.5
!
! Local variables
!
! index variables
        INTEGER :: nlp, k, nl, s
        INTEGER :: kb
!
        REAL :: dtlim, f1
        REAL :: f1b
        REAL :: tot1, tot2
        REAL :: dts, delc, m1up
        REAL :: delcb
        REAL*8 :: ai(nlays), bi(nlays), ei(nlays)
        REAL*8 :: di(nlays), ui(nlays)
        REAL*8 :: alpha, beta, gama
        REAL*8 :: betab
        REAL :: vci(nlays, nsp)
        REAL :: mbarks(nlays), mdwn(nlays)
        REAL :: dsigh(nlays), dsighi(nlays)
        REAL*8 :: tmp
        REAL*8 :: tmp0
        REAL*8 :: uib(nlays)
        REAL*8 :: tempb1
        REAL*8 :: tempb0
        REAL*8 :: tmpb
        REAL*8 :: tmp0b
        REAL*8 :: dib(nlays)
        REAL :: tempb
        INTRINSIC INT
        REAL :: vcib(nlays, nsp)
        INTRINSIC MIN
        INTEGER :: ii2
        INTEGER :: ii1
!
!-----------------------------------------------------------------------
!
        dtlim = dtcld
        mdwn(cltop+1) = 0.0
        dsigh(cltop+1) = 1.0
        sigmaf(0) = 1
        m1up = 0.0
        kb = clbase - 1
        clbase = clbase
        dsigh(kb) = sigmaf(kb) - 1.0
        dsighi(kb) = 1.0/dsigh(kb)
!
! Compute ACM mixing rate
!
        DO k=cltop,clbase,-1
          dsigh(k) = sigmaf(k) - sigmaf(k-1)
          dsighi(k) = 1.0/dsigh(k)
          mbarks(k) = (1.0-f(k))*frac/tclife
          mdwn(k) = mbarks(k) + mdwn(k+1)*dsigh(k+1)*dsighi(k)
          m1up = m1up + mbarks(k)*dsigh(k)
          IF (half/(m1up*dsighi(k)) .GT. dtlim) THEN
            dtlim = dtlim
          ELSE
            dtlim = half/(m1up*dsighi(k))
          END IF
        END DO
        IF (half/(m1up*dsighi(kb)) .GT. dtlim) THEN
          dtlim = dtlim
        ELSE
          dtlim = half/(m1up*dsighi(kb))
        END IF
!
        nlp = INT(dtcld/dtlim + 1.0)
        dts = dtcld/nlp
! end timestep loop
! loop over sub timestep
        DO nl=1,nlp
! end loop for species
! loop over species
          DO s=1,nsp
! Compute tendency of CBL concentrations - Semi-Implicit solution
!
            DO k=clbase,cltop
              CALL PUSHREAL8(ei(k))
              ei(k) = -(crankp*mdwn(k)*dts*dsigh(k)*dsighi(k-1))
              CALL PUSHREAL8(bi(k))
              bi(k) = 1.0 + crankp*mdwn(k)*dts
              CALL PUSHREAL8(ai(k))
              ai(k) = -(crankp*mbarks(k)*dts)
            END DO
            CALL PUSHREAL8(bi(kb))
!
            bi(kb) = 1.0 + crankp*m1up*dts*dsighi(kb)
            CALL PUSHREAL8(gama)
!
! Define arrays A,B,E which make up matrix and D which is RHS
!
            gama = bi(kb)
            CALL PUSHREAL8(alpha)
            alpha = 1.0
            DO k=clbase,cltop
              CALL PUSHREAL8(alpha)
              alpha = -(alpha*ei(k)/bi(k))
              gama = alpha*ai(k) + gama
            END DO
          END DO
        END DO
        DO ii1=1,nsp
          DO ii2=1,nlays
            vcib(ii2, ii1) = 0.0
          END DO
        END DO
        DO s=nsp,1,-1
          DO k=cltop,clbase,-1
            vcib(k, s) = vcib(k, s) + cb(s, k)
            cb(s, k) = 0.0
          END DO
          vcib(kb, s) = vcib(kb, s) + cbelowb(s)
          cbelowb(s) = 0.0
        END DO
        DO ii1=1,nlays
          dib(ii1) = 0.0_8
        END DO
        DO ii1=1,nlays
          uib(ii1) = 0.0_8
        END DO
        DO nl=nlp,1,-1
          DO s=nsp,1,-1
            DO k=cltop,kb,-1
              uib(k) = uib(k) + vcib(k, s)
              vcib(k, s) = 0.0
            END DO
            DO k=clbase,cltop-1,1
              tmp0b = uib(k)
              uib(k) = 0.0_8
              tempb1 = tmp0b/bi(k)
              dib(k) = dib(k) + tempb1
              uib(kb) = uib(kb) - ai(k)*tempb1
              uib(k+1) = uib(k+1) - ei(k+1)*tempb1
            END DO
            tmpb = uib(cltop)
            uib(cltop) = 0.0_8
            tempb0 = tmpb/bi(cltop)
            dib(cltop) = dib(cltop) + tempb0
            uib(kb) = uib(kb) - ai(cltop)*tempb0
            betab = uib(kb)/gama
            uib(kb) = 0.0_8
            DO k=cltop,clbase,-1
              dib(k) = dib(k) + alpha*betab
              CALL POPREAL8(alpha)
            END DO
            CALL POPREAL8(alpha)
            CALL POPREAL8(gama)
            dib(kb) = dib(kb) + betab
            f1b = -((1.0-crankp)*dsighi(kb)*dts*dib(kb))
            vcib(kb, s) = vcib(kb, s) + m1up*f1b + dib(kb)
            dib(kb) = 0.0_8
            vcib(clbase, s) = vcib(clbase, s) - mdwn(clbase)*dsigh(clbase)*f1b
            CALL POPREAL8(bi(kb))
            DO k=cltop,clbase,-1
              CALL POPREAL8(ai(k))
              CALL POPREAL8(bi(k))
              CALL POPREAL8(ei(k))
              vcib(k, s) = vcib(k, s) + dib(k)
              delcb = (1.0-crankp)*dib(k)
              dib(k) = 0.0_8
              tempb = dts*delcb
              vcib(kb, s) = vcib(kb, s) + mbarks(k)*tempb
              vcib(k, s) = vcib(k, s) - mdwn(k)*tempb
              vcib(k+1, s) = vcib(k+1, s) + dsigh(k+1)*dsighi(k)*mdwn(k+1)*
     +          tempb
            END DO
          END DO
        END DO
        DO s=nsp,1,-1
          DO k=cltop,clbase,-1
            cb(s, k) = cb(s, k) + vcib(k, s)
            vcib(k, s) = 0.0
          END DO
          vcib(cltop+1, s) = 0.0
          cbelowb(s) = cbelowb(s) + vcib(kb, s)
          vcib(kb, s) = 0.0
        END DO
      END SUBROUTINE ACMCLD_B
