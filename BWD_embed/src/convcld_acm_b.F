!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.10 (r5537) -  9 Feb 2015 10:01
!
!  Differentiation of convcld_acm in reverse (adjoint) mode:
!   gradient     of useful results: cgrid
!   with respect to varying inputs: cgrid
!
!***********************************************************************
!   Portions of Models-3/CMAQ software were developed or based on      *
!   information from various groups: Federal Government employees,     *
!   contractors working on a United States Government contract, and    *
!   non-Federal sources (including research institutions).  These      *
!   research institutions have given the Government permission to      *
!   use, prepare derivative works, and distribute copies of their      *
!   work in Models-3/CMAQ to the public and to permit others to do     *
!   so.  EPA therefore grants similar permissions for use of the       *
!   Models-3/CMAQ software, but users are requested to provide copies  *
!   of derivative works to the Government without restrictions as to   *
!   use by others.  Users are responsible for acquiring their own      *
!   copies of commercial software associated with Models-3/CMAQ and    *
!   for complying with vendor requirements.  Software copyrights by    *
!   the MCNC Environmental Modeling Center are used with their         *
!   permissions subject to the above restrictions.                     *
!***********************************************************************
!
! RCS file, release, date & time of last delta, author, state, [and locker]
! $Header$
!
! what(1) key, module and SID; SCCS file; date and time of last delta:
! %W% %P% %G% %U%
!
!:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      SUBROUTINE CONVCLD_ACM_B(cgrid, cgridb, jdate, jtime, tstep, n_spc_wdep
     + , wdep_map, conv_dep)
!
!-----------------------------------------------------------------------
!
!  FUNCTION: Convective cloud processor Models-3 science process:
!       MAIN ROUTINE calculates cloud characteristics, and uses them
!       to generate cumulative and net timestep deposition, cloud top,
!       cloud bottom, and pressure at the lifting level.
!
!       ICLDTYPE = 1 => computes raining cloud physics, mixing, chemistry,
!                       wet dep
!       ICLDTYPE = 2 => does the same for non-precip clouds utilizing saved
!                       info from RNCLD in the case of co-existing clouds
!
!  PRECONDITIONS REQUIRED:
!       Dates and times represented YYYYDDD:HHMMSS.
!
!  IDEA:   Aqueous chemistry operates on the half-hour for an internal
!          time step of one hour.
!
!  REVISION  HISTORY:
!       Adapted 3/93 by CJC from science module template
!       Version 3/3/93 with complete LCM aqueous chem by JNY.
!       Modified 6/3-7/93 by CJC & JNY to correct treatment of half layers
!       vs. full layers in loop 255:  calculation of DTDP centered at
!       quarter-layers using PSTAR; corresponding revisions to TLCL, TSAT.
!       Uses 4th order R-K solver there.
!       Version 6/5/93 by CJC using relative rainout rates.
!       Version 7/6/93 by CJC using INTERP3()
!       Adapted from LCM aqueous chemistry, initial version, 9/93
!              by JNY and CJC
!       Completion of EM cloud mixing, JNY 12/93
!       Inclusion of EM aqueous chemistry JNY 12/93
!       UPGRADE TO FULL RADM CLOUD MODULE EMULATION, JNY 4/94
!       8/16/94 by Dongming Hwang Configuration management template
!       Adapted 10/96 by S.Roselle for Models-3
!       1/97 s.roselle added McHenry's well mixed assumption code
!       8/97 S.Roselle revised cgrid units, pressure units, rainfall
!              to hourly amounts, built indices for wet dep species,
!              scavenged species, and aqueous species, built wrapper
!              around aqueous chemistry module
!       10/97 S.Roselle removed McHenry's well mixed assumption code
!              and put back the below cloud concentration scaling
!       11/97 S.Roselle moved the wet deposition output to the calling
!              routine--CLDPROC
!       01/98 S.Roselle moved indexing code to AQINTER, also
!              moved scavenging to SCAVWDEP
!       03/98 S.Roselle read sub-hourly rainfall data
!       12/98 David Wong at LM:
!             -- changed division of 8000, 2, 1000 to its corresponding
!                reciprocal
!              -- added INT in the expression STEP * 0.5 when calling SEC2TIME
!       03/99 David Wong at LM:
!             -- replaced "/ FRAC * .001" by "/ ( FRAC * 1000.0 )" to minimize
!                lost of significant digits in calculation
!       Jeff - Dec 00 - move CGRID_MAP into f90 module
!       Jeff - Sep 01 - Dyn Alloc - Use HGRD_DEFN
!       4/02 S.Roselle changed minimum horizontal resolution for subgrid
!             clouds from 12km to 8km.
!       1/05 J.Young: dyn alloc - establish both horizontal & vertical
!                     domain specifications in one module
!       5/05 J.Pleim Replaced cloud mixing algorithm with ACM
!       6/05 S.Roselle added new cloud diagnostic variables
!       7/05 J.Young: clean up and mod for CMAQ-F
!       8/10 J.Young: replace chem mechanism include files with namelists
!                    and accomodate Shawn Roselle's, Sergey Napelenok's
!                    and Steve Howard's aerosol reengineering
!-----------------------------------------------------------------------
!
! horizontal & vertical domain specifications
        USE GRID_CONF
!
! CGRID species number and offsets
        USE CGRID_SPCS
        IMPLICIT NONE

C...........INCLUDES

#ifdef Incl
      INCLUDE SUBST_GC_SPC              ! gas chemistry species table
      INCLUDE SUBST_AE_SPC              ! aerosol species table
      INCLUDE SUBST_NR_SPC              ! non-reactive species table
      INCLUDE SUBST_TR_SPC              ! tracer species table
#endif
      INCLUDE SUBST_CONST               ! constants
      INCLUDE SUBST_FILES_ID            ! file name parameters
      INCLUDE SUBST_IOPARMS             ! I/O parameters definitions
      INCLUDE SUBST_IOFDESC             ! file header data structuer
      INCLUDE SUBST_IODECL              ! I/O definitions and declarations
!
!
!
!
! Exit status message
        CHARACTER(len=120), SAVE :: xmsg=' '
!
!...........Parameters
!
! critical rel humidity, lower bound (fraction)
        REAL, PARAMETER :: rcrit1=0.7
!
! critical rel humidity, upper bound (fraction)
        REAL, PARAMETER :: rcrit2=0.9
!
! param contlng sidewall entrainment function for raining clouds
        REAL, PARAMETER :: sidefac=0.5
!
! storm rainout efficiency
        REAL, PARAMETER :: storme=0.3
!
! emp sat vapor press constant from RADM
        REAL, PARAMETER :: c303=19.83
!
! emp sat vapor press constant from RADM
        REAL, PARAMETER :: c302=5417.4
!
! g/kg
        REAL, PARAMETER :: gpkg=1.0e+03
!
! 1 hectare = 1.0e4 m**2
        REAL, PARAMETER :: m2pha=1.0e+04
!
! subgrid scale temp perturb (deg K)
        REAL, PARAMETER :: pert=1.5
!
! " wvp mix ratio perturb (dimensionless)
        REAL, PARAMETER :: perq=1.5e-3
!
! rainfall threshold in mm/hr (mm/hr)
        REAL, PARAMETER :: rthresh=0.1
!
! vapor press of water at 0 C (Pa)
        REAL, PARAMETER :: vp0pa=611.2
!
! 1.0 / (vapor press of water @ 0 C) (1/Pa)
        REAL, PARAMETER :: vpinv=1.0/vp0pa
!
! converg. crit. for entrainment solver
        REAL, PARAMETER :: tst=0.01
!
! assumed cloud lifetime for convective clouds (sec)
        REAL, PARAMETER :: tclife=3600.0
!
! ratio of mol wt of water vapor to mol wt of air
        REAL, PARAMETER :: mvoma=mwwat/mwair
!
! ratio of dry gas const to specific heat
        REAL, PARAMETER :: rovcp=rdgas/cpd
!
! ratio of latent heat of vap to specific heat
        REAL, PARAMETER :: lvocp=lv0/cpd
!
! dry adiabatic lapse rate (deg K/m)
        REAL, PARAMETER :: dalr=grav/cpd
!
! Number of species in CGRID
!
        INTEGER, PARAMETER :: mxspcs=n_gc_spcd+n_ae_spc+n_nr_spc+n_tr_spc
!
!
! parameter to control frequency of convective cloud processing
!   SYNCCLD=.TRUE.  : every synchronization timestep
!   SYNCCLD=.FALSE. : every hour on the half hour
! default to sync timestep
        LOGICAL, PARAMETER :: synccld=.true.
!
!...........Arguments
!
!     REAL          CGRID( NCOLS,NROWS,NLAYS,* )  ! concentrations
! concentrations
        REAL :: cgrid(:, :, :, :)
        REAL, POINTER :: cgridb(:, :, :, :)
!      REAL, POINTER :: CGRID( :,:,:,: )           ! concentrations
! current model date, coded YYYYDDD
        INTEGER :: jdate
! current model time, coded HHMMSS
        INTEGER :: jtime
! model time step, coded H*MMSS
        INTEGER :: tstep(2)
! 1: raining, 2: either CNP or PFW
        INTEGER :: icldtype
! # of wet deposition species
        INTEGER :: n_spc_wdep
!     INTEGER       WDEP_MAP( * )       ! wet deposition map to CGRID
! wet deposition map to CGRID
        INTEGER :: wdep_map(:)
!     REAL          CONV_DEP( NCOLS, NROWS, * )  ! depositions (etc.)
! depositions (etc.)
        REAL :: conv_dep(:, :, :)
!
!...........Local Variables
!
!-------for ACM version - jp 2/05        REAL DPB
        REAL, ALLOCATABLE, SAVE :: sigf(:)
!        REAL, ALLOCATABLE, SAVE :: sigfb(:)
!
        REAL :: ccr(mxspcs, nlays), conc(mxspcs, nlays), cbelow(mxspcs)
        REAL :: ccrb(mxspcs, nlays), concb(mxspcs, nlays), cbelowb(mxspcs)
!
!-------------------------------------------
        INTEGER, SAVE :: logdev
!
! flag for first pass thru
        LOGICAL, SAVE :: firstime=.true.
! flag for modeling convective clds
        LOGICAL, SAVE :: convcld=.true.
!
! prcess name
        CHARACTER(len=16), SAVE :: pname='CONVCLD_ACM_b'
! variable name for IOAPI to get
        CHARACTER(len=16) :: varnm
!
! time diff from half-hour
        INTEGER :: atime
! model LAY containing cloud top
        INTEGER :: cltop
! column loop counter
        INTEGER :: col
! row loop counter
        INTEGER :: row
! dummy variable for cloud top layer
        INTEGER :: ctop
! ending position
        INTEGER :: fini
! entrainment solver iteration counter
        INTEGER :: i599c
! layer loop counter
        INTEGER :: lay
! process date
        INTEGER :: mdate
! process time (half-hour)
        INTEGER :: mtime
! met file time step (hhmmss)
        INTEGER, SAVE :: mstep
! met file start date
        INTEGER, SAVE :: sdate
! liquid species loop counter
        INTEGER :: spc
! step loop counter
        INTEGER :: step
! starting position
        INTEGER :: strt
! met file start time
        INTEGER, SAVE :: stime
! variable loop counter
        INTEGER :: var
!
!     INTEGER       CLBASE    ( NCOLS, NROWS ) ! cld base layer
!     SAVE          CLBASE
!     INTEGER       CLTOPUSTBL( NCOLS, NROWS ) ! unstable cld top layer
!     SAVE          CLTOPUSTBL
!     INTEGER       IRNFLAG   ( NCOLS, NROWS ) ! 0: no raining cld 1: raining cloud
!     SAVE          IRNFLAG
!     INTEGER       ISOUND    ( NCOLS, NROWS ) ! flag for sounding stability
!     SAVE          ISOUND
!     INTEGER       SRCLAY    ( NCOLS, NROWS ) ! cloud source level vert index
!     SAVE          SRCLAY
!     INTEGER, ALLOCATABLE, SAVE :: CLBASE    ( :,: ) ! cld base layer
! cld base layer
        INTEGER :: clbase
!     INTEGER, ALLOCATABLE, SAVE :: CLTOPUSTBL( :,: ) ! unstable cld top layer
! unstable cld top layer
        INTEGER :: cltopustbl
!     INTEGER, ALLOCATABLE, SAVE :: IRNFLAG   ( :,: ) ! 0: no raining cld 1: raining cloud
!     INTEGER, ALLOCATABLE, SAVE :: ISOUND    ( :,: ) ! flag for sounding stability
! flag for sounding stability
        INTEGER :: isound
!     INTEGER, ALLOCATABLE, SAVE :: SRCLAY    ( :,: ) ! cloud source level vert index
! cloud source level vert index
        INTEGER :: srclay
!
! total air mass (moles/m2) in cloudy air
        REAL :: airm
! moles/m2 air below cloud
        REAL :: airmb0
! inverse moles/m2 air below cloud
        REAL :: airmbi
! aitken mode number scavenging coef
        REAL :: alfa0
        REAL :: alfa0b
! aitken mode sfc area scavenging coef
        REAL :: alfa2
        REAL :: alfa2b
! aitken mode mass scavenging coef
        REAL :: alfa3
        REAL :: alfa3b
! ave cloud pres in atm
        REAL :: arpres
!
        REAL :: condis
        REAL :: condisb
! cloud thickness (m)
        REAL :: cthk
! aq chem calc cloud thickness
        REAL :: cthk1
! dry adiabatic minus dew point lapse rate
        REAL :: damdp
! pressure increment along moist adiabat
        REAL :: dp
! dew point lapse rate
        REAL :: dplr
! change in ice mix ratio due to melting caused by entrainment
        REAL :: dqi
! change in liq wat mix ratio due to evap caused by entrainment
        REAL :: dql
! cloud integration timestep (s)
        REAL :: dtcld
! moist adiabatic lapse rate
        REAL :: dtdp
! height increment to LCL above source level
        REAL :: dzlcl
! height of LCL above ground
        REAL :: zlcl
! water vapor pressure at source level
        REAL :: emax
! parcel equivalent potential temperature
        REAL :: eqth
! parcel equivalent potential temp
        REAL :: eqthm
! entrainment functional value at TEMPA
        REAL :: fa
! entrainment functional value at TEMPB
        REAL :: fb
! cloud fractional coverage
        REAL :: frac
! functional product in Walcek bisection solver
        REAL :: ftst
! temp diff in Walcek bisection solver
        REAL :: htst
! timestep on the met file
        REAL :: metstep
        SAVE metstep
! intermediate pressure used in calculating WL
        REAL :: p1
! intermediate pressure used in calculating WL
        REAL :: p2
! intermediate pressure used in calculating WL
        REAL :: p3
! mean pressure in vertical increments up from LCL along moist adiabat
        REAL :: pbar
! mean cloud pressure (Pa)
        REAL :: pbarc
! parcel pressure
        REAL :: pmax
! scratch pressure variable
        REAL :: pp
! total rainfall (mm/hr)
        REAL :: prate
! storm rainfall rate (mm/hr)
        REAL :: prate1
! wat vap mix ratio due to cld sidewall entrainmt
        REAL :: qent
! perturbed water vap mix ratio of parcel
        REAL :: qp
! int. excess wat ov grid cell needed for rainout
        REAL :: qxs
! variable storing H+ deposition
        REAL :: removac
! air density in kg/m3
        REAL :: rhoair
! relative humidity
        REAL :: rlh
! relative humidity at cld src level
        REAL :: rlhsrc
! chemical gas const times temp
        REAL :: rtch
! perturbed temp to calc neutral buoyancy also used as max temp in cell comparing cloud with environment
        REAL :: t1
! mean temp in vertical increments up from LCL along moist adiabat
        REAL :: tbar
! mean cloud temp (K)
        REAL :: tbarc
! iterative temp along moist adiabat
        REAL :: tbase
! dew point at source level
        REAL :: tdmax
! lower limit on temp for entrainment solver
        REAL :: tempa
! upper limit on temp for entrainment solver
        REAL :: tempb
! scratch temp solved for cloudy air parcel
        REAL :: tempc
! temp accounting for cld sidewall entrainment
        REAL :: tent
! parcel potential temperature
        REAL :: thmax
! init temp of cloud air before evap of water
        REAL :: ti
! temp at LCL
        REAL :: tlcl
! perturbed temp of parcel
        REAL :: tmax
! perturbed temp of parcel
        REAL :: tp
! scr vbl used in application of Eq. 7, W&T
        REAL :: ttop
! tot wat cont in cloud (kg H2O/m3 air)
        REAL :: twc
! liq water content of cloud (kg/m3)
        REAL :: wcbar
! Warner profile (an earlier version appears appears in Walcek and Taylor (JAS, 1986)
        REAL :: wl
! total wat cont (kg/m2) int. thru cloud depth
        REAL :: wtbar
! intermediate vbles in lapse rate calculation X1 also reused as scratch vble in mixing
        REAL :: x1
! scratch vbl used in entrainment solver
        REAL :: xxxx
!
! array of minimum concentrations
        REAL, SAVE :: aeconcmin(n_ae_spcd)
! moles/m2 species below cloud
        REAL :: bmol(mxspcs)
        REAL :: bmolb(mxspcs)
! initial ave trace gas mix rat below cld
        REAL :: cbase0(mxspcs)
        REAL :: cbase0b(mxspcs)
! final ave trac gas mix rat blw cld (moles/mole)
        REAL :: cbasef(mxspcs)
        REAL :: cbasefb(mxspcs)
! ending equiv gas phase conc (moles/mole)
        REAL :: cend(mxspcs)
        REAL :: cendb(mxspcs)
! ave vert conc incloud moles sp/m2 and moles sp/ mole air
        REAL :: polc(mxspcs)
        REAL :: polcb(mxspcs)
! moles/m2 or mm*mol/lit scavenged
        REAL :: remov(mxspcs)
!
! air density (kg/m3)
        REAL :: densl(nlays)
! cloud entrainment fraction to be solved for
        REAL :: f(nlays)
! sidewall entrainment vertical profile
        REAL :: fside(nlays)
! liq wat cont of cloud in kg H2O/m3 air
        REAL :: lwc(nlays)
! ice mixing ratio in cloud
        REAL :: qice(nlays)
! actual liq. wat. mix ratio in cloud
        REAL :: qlqd(nlays)
! saturation wat vap mix ratio at T1
        REAL :: qvc(nlays)
! liq wat mix rat, taken as total condensed water (ice + liq) profile (Eq.4, W&T)
        REAL :: qwat(nlays)
! moles/m2 air
        REAL :: rhom2(nlays)
! temp of cloudy air parcel
        REAL :: tcld(nlays)
!
!     REAL          ACTRNMA( NCOLS, NROWS ) ! actual fraction of below cld layer mass convected into raining cloud
!     SAVE          ACTRNMA
!     REAL          FRACMAX( NCOLS, NROWS ) !  max frac cov for NP cld
!     SAVE          FRACMAX
!     REAL          FWXFRAC( NCOLS, NROWS ) ! storage array for actual NP cld frac
!     SAVE          FWXFRAC
!     REAL          PLCL   ( NCOLS, NROWS ) ! pressure at LCL
!     SAVE          PLCL
!     REAL          QMAX   ( NCOLS, NROWS ) ! pertbd w.. mix rat of parcel
!     SAVE          QMAX
!     REAL          TOTFRAC( NCOLS, NROWS ) !  total frac cloud cover
!     SAVE          TOTFRAC
!     REAL, ALLOCATABLE, SAVE :: ACTRNMA( :,: ) ! actual fraction of below cld layer mass convected into raining cloud
!     REAL, ALLOCATABLE, SAVE :: FRACMAX( :,: ) !  max frac cov for NP cld
!  max frac cov for NP cld
        REAL :: fracmax
!     REAL, ALLOCATABLE, SAVE :: PLCL   ( :,: ) ! pressure at LCL
! pressure at LCL
        REAL :: plcl
!     REAL, ALLOCATABLE, SAVE :: QMAX   ( :,: ) ! pertbd w.. mix rat of parcel
! pertbd w.. mix rat of parcel
        REAL :: qmax
!     REAL, ALLOCATABLE, SAVE :: TOTFRAC( :,: ) !  total frac cloud cover
!  this timestep rainfall (mm/hr)
        REAL :: rain(ncols, nrows)
!
! below cloud weighting function
        REAL :: bcldwt(mxspcs, nlays)
        REAL :: bcldwtb(mxspcs, nlays)
! minimum concentrations for each species and layer
        REAL :: concminl(mxspcs, nlays)
! fin. in cloud conc. after mix and chem moles/mole
        REAL :: incloud(mxspcs, nlays)
        REAL :: incloudb(mxspcs, nlays)
! fin. outside cld conc. "   "   "   " moles/mole
        REAL :: outcloud(mxspcs, nlays)
        REAL :: outcloudb(mxspcs, nlays)
! moles sp/mole air in cloud
        REAL :: pcld(mxspcs, nlays)
        REAL :: pcldb(mxspcs, nlays)
!
!
! hourly convective rainfall (cm)
        REAL :: rc(ncols, nrows)
! PBL height (m)
        REAL :: pbl(ncols, nrows)
! computed gridded vble
        REAL :: dzz(ncols, nrows, nlays)
! grid cell delta Z
        REAL :: dzzl(nlays)
! file gridded vble
        REAL :: pres(ncols, nrows, nlays)
! grid cell pressure
        REAL :: presl(nlays)
!     REAL          QAD  ( NCOLS, NROWS, NLAYS )  ! moist adiab. sat. mix ratio
!     SAVE          QAD
!     REAL, ALLOCATABLE, SAVE :: QAD  ( :,:,: )  ! moist adiab. sat. mix ratio
! moist adiab. sat. mix ratio
        REAL :: qad(nlays)
! input gridded vble
        REAL :: qv(ncols, nrows, nlays)
! grid cell sp. hum.
        REAL :: qvl(nlays)
! input gridded vble
        REAL :: ta(ncols, nrows, nlays)
! grid cell temp
        REAL :: tal(nlays)
!     REAL          TSAT ( NCOLS, NROWS, NLAYS )  ! parcel temp along moist adiabat @ half levels
!     SAVE          TSAT
!     REAL, ALLOCATABLE, SAVE :: TSAT ( :,:,: )  ! parcel temp along moist adiabat @ half levels
! parcel temp along moist adiabat @ half levels
        REAL :: tsat(nlays)
! mid-layer height (m)
        REAL :: zh(ncols, nrows, nlays)
! level/layer-face height (m)
        REAL :: zf(ncols, nrows, nlays)
!
        INTEGER :: allocstat
!
! global origin offset from file
        INTEGER :: gxoff, gyoff
! for INTERPX
        INTEGER, SAVE :: strtcolmc2, endcolmc2, strtrowmc2, endrowmc2
        INTEGER, SAVE :: strtcolmc3, endcolmc3, strtrowmc3, endrowmc3
!
!...........External Functions
!
        LOGICAL, EXTERNAL :: CURRSTEP
        INTEGER, EXTERNAL :: SEC2TIME, SECSDIFF, TIME2SEC, SETUP_LOGDEV
!
!...........Statement Functions
!
! sat vap pres (Pa) as fn of T (deg K)
        REAL :: esat
! sat water vapor mixing ratio
        REAL :: qsat
!
! temperature dummy arg
        REAL :: t
! sat vapor pressure dummy arg
        REAL :: e
! pressure dummy arg
        REAL :: p
        INTRINSIC FLOAT
        INTRINSIC REAL
        INTRINSIC MAX
        INTRINSIC EXP
        INTRINSIC ALOG
        INTRINSIC MIN
        INTRINSIC INDEX
        INTEGER :: result1
        LOGICAL :: result10
        LOGICAL :: res
        LOGICAL :: res0
        LOGICAL :: res1
        LOGICAL :: res2
        LOGICAL :: res3
        LOGICAL :: res4
        LOGICAL :: res5
        LOGICAL :: res6
        LOGICAL :: res7
        LOGICAL :: res8
        INTEGER :: ad_to
        INTEGER :: branch
        INTEGER :: ad_count
        INTEGER :: i
        INTEGER :: ad_to0
        INTEGER :: ad_to1
        INTEGER :: ad_to2
        INTEGER :: ad_to3
        INTEGER :: ad_from
        INTEGER :: ad_to4
        INTEGER :: ad_from0
        INTEGER :: ad_to5
        INTEGER :: ad_from1
        INTEGER :: ad_to6
        INTEGER :: ad_to7
        INTEGER :: ad_from2
        INTEGER :: ad_to8
        INTEGER :: ad_to9
        INTEGER :: ad_to10
        INTEGER :: ad_to11
        INTEGER :: ad_to12
        INTEGER :: ad_to13
        INTEGER :: ad_to14
        INTEGER :: ad_from3
        INTEGER :: ad_to15
        REAL :: temp0
        REAL :: max2b
        REAL :: tempb2
        REAL :: tempb1
        REAL :: tempb0
        REAL :: max1b
        REAL :: max3b
        REAL :: temp
        REAL :: max3
        REAL :: max2
        REAL :: max1

        double precision, parameter :: onedp=1.d0
        logical :: mmb(ncols,nrows)
        real :: concbchk(mxspcs, nlays), concbchkmin(mxspcs,nlays), concbchkmax(mxspcs,nlays)
        real :: concbchkmin_int(mxspcs), concbchkmax_int(mxspcs)
! Firstime
!
!
!
!-----------------------------------------------------------------------
!  begin body of subroutine CONVCLD_ACM
!
!...INITIALIZATION for the CONVCLD_ACM module:
!...  event-statistics variables.
!
        IF (firstime) THEN

        FIRSTIME = .FALSE.
          logdev = INIT3()
!
          IF (n_ae_spc .GT. 0) CALL SET_AECONCMIN(aeconcmin)
!
C...check the grid resolution from the MET_CRO_2D and set an appropriate
C...  flag as to whether convective clouds should be run for the given
C...  resolution

C...open MET_CRO_3D

        IF ( .NOT. OPEN3( MET_CRO_3D, FSREAD3, PNAME ) ) THEN
          XMSG = 'Could not open '// MET_CRO_3D // ' file'
          CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
        END IF

C...get description from the met file

        IF ( .NOT. DESC3( MET_CRO_2D ) ) THEN
          XMSG = 'Could not get ' // MET_CRO_2D //' file description'
          CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
        END IF

C...set flag to false if grid scale is less than 8 km

        IF ( ( XCELL3D .LT. 8000.0 ) .OR.
     &       ( YCELL3D .LT. 8000.0 ) ) THEN
          CONVCLD = .FALSE.
          XMSG = 'Grid resolution too small to run a sub-grid-scale '//
     &           'convective cloud scheme.'
          CALL M3WARN ( PNAME, JDATE, JTIME, XMSG )
          XMSG = 'An explicit cloud scheme should be used.'
          CALL M3MESG ( XMSG )
        END IF

!...store met file time, date, and step information and compute
!...  the met timestep in hours
!
!
        SDATE = SDATE3D
        STIME = STIME3D
        MSTEP = TSTEP3D
!
!...get horizontal domain window from met data
!
!slzdbg        CALL SUBHFILE ( MET_CRO_2D, GXOFF, GYOFF,
!slzdbg     &                  STRTCOLMC2, ENDCOLMC2, STRTROWMC2, ENDROWMC2 )
!slzdbg
!slzdbg        CALL SUBHFILE ( MET_CRO_3D, GXOFF, GYOFF,
!slzdbg     &                  STRTCOLMC3, ENDCOLMC3, STRTROWMC3, ENDROWMC3 )
!
!...allocate saved arrays
!
!       ALLOCATE ( FRACMAX   ( MY_NCOLS,MY_NROWS ), STAT = ALLOCSTAT )
!       ALLOCATE ( TOTFRAC   ( MY_NCOLS,MY_NROWS ), STAT = ALLOCSTAT )
!       ALLOCATE ( IRNFLAG   ( MY_NCOLS,MY_NROWS ), STAT = ALLOCSTAT )
!       IF ( ALLOCSTAT .NE. 0 ) THEN
!          XMSG = 'Failure allocating FRACMAX or TOTFRAC or IRNFLAG'
!          CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!       END IF
!       ALLOCATE ( ACTRNMA   ( MY_NCOLS,MY_NROWS ), STAT = ALLOCSTAT )
!       ALLOCATE ( CLBASE    ( MY_NCOLS,MY_NROWS ), STAT = ALLOCSTAT )
!       ALLOCATE ( CLTOPUSTBL( MY_NCOLS,MY_NROWS ), STAT = ALLOCSTAT )
!       IF ( ALLOCSTAT .NE. 0 ) THEN
!          XMSG = 'Failure allocating ACTRNMA or CLBASE or CLTOPUSTBL'
!          CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!       END IF
!       ALLOCATE ( QMAX      ( MY_NCOLS,MY_NROWS ), STAT = ALLOCSTAT )
!       ALLOCATE ( PLCL      ( MY_NCOLS,MY_NROWS ), STAT = ALLOCSTAT )
!       ALLOCATE ( SRCLAY    ( MY_NCOLS,MY_NROWS ), STAT = ALLOCSTAT )
!       IF ( ALLOCSTAT .NE. 0 ) THEN
!          XMSG = 'Failure allocating QMAX or PLCL or SRCLAY'
!          CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!       END IF
!       ALLOCATE ( ISOUND( MY_NCOLS,MY_NROWS ), STAT = ALLOCSTAT )
!       ALLOCATE ( QAD   ( MY_NCOLS,MY_NROWS,NLAYS ), STAT = ALLOCSTAT )
!       ALLOCATE ( TSAT  ( MY_NCOLS,MY_NROWS,NLAYS ), STAT = ALLOCSTAT )
!       IF ( ALLOCSTAT .NE. 0 ) THEN
!          XMSG = 'Failure allocating ISOUND or QAD or TSAT'
!          CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!       END IF
!
        METSTEP = FLOAT( TIME2SEC( MSTEP ) ) / 3600.0

C...get horizontal domain window from met data

        CALL SUBHFILE ( MET_CRO_2D, GXOFF, GYOFF,
     &                  STRTCOLMC2, ENDCOLMC2, STRTROWMC2, ENDROWMC2 )

        CALL SUBHFILE ( MET_CRO_3D, GXOFF, GYOFF,
     &                  STRTCOLMC3, ENDCOLMC3, STRTROWMC3, ENDROWMC3 )

!          ALLOCATE(sigfb(0:nlays), stat=allocstat)
          ALLOCATE(sigf(0:nlays), stat=allocstat)
        IF ( ALLOCSTAT .NE. 0 ) THEN
          XMSG = 'Failure allocating SIGF'
          CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
        END IF
!slz          CALL PUSHCONTROL1B(0)
!
          DO lay=1,nlays
            sigf(lay) = 1 - x3face_gd(lay)
          END DO
          sigf(0) = 1.0
!
!
!
!        ELSE
!slz          CALL PUSHCONTROL1B(1)
        END IF
!
!...check option for processing clouds on the synchronization timestep
!
        IF (synccld) THEN
          CALL PUSHCONTROL1B(0)
          mdate=jdate
          mtime=jtime
!
!...set the cloud timestep (=adv timestep)
!
! syncronization timestep
          step = TIME2SEC(tstep(2))
          dtcld = REAL(step)
          CALL NEXTIME ( MDATE, MTIME, SEC2TIME( STEP / 2 ) )
!
!...set time to the midpoint of this timestep for data interpolation
!
!
!...otherwise, revert back to processing convective cloud once per hour
!...  on the half hour
!
        ELSE
!
!...Check to see if this time step contains the half-hour
!...  if it does not, then return
!
          mdate = jdate
! on the current hour
          mtime = 10000*(jtime/10000)
! syncronization timestep
          step = TIME2SEC(tstep(2))
          dtcld = tclife
!
!...  set mdate:mtime to one-half step before the half-hour
!
          result1 = SEC2TIME(1800 - step/2)
          CALL NEXTIME(mdate, mtime, result1)
!
          atime = SECSDIFF(mdate, mtime, jdate, jtime)
!
          IF ((atime .LT. 0 .OR. atime .GE. step) .OR. (.NOT.convcld)) THEN
            GOTO 200
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
        END IF
!
!...ACTUAL SCIENCE PROCESS (loop on internal process time steps):
!...  Interpolate time dependent layered input variables
!...  (reading those variables for which it is necessary)
!
!...  Get ambient temperature (K)
!
!     ALLOCATE ( TA( MY_NCOLS,MY_NROWS,NLAYS ), STAT = ALLOCSTAT )
!     IF ( ALLOCSTAT .NE. 0 ) THEN
!        XMSG = 'Failure allocating TA'
!        CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!     END IF
!
!     IF ( .NOT. INTERP3( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                    NCOLS * NROWS * NLAYS, TA ) ) THEN
!
!...Get specific humidity (kg H2O / kg air)
!
      VARNM = 'TA'
      IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MDATE, MTIME, TA ) ) THEN
        XMSG = 'Could not read TA from' // MET_CRO_3D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
      END IF

C...Get specific humidity (kg H2O / kg air)


!     ALLOCATE ( QV( MY_NCOLS,MY_NROWS,NLAYS ), STAT = ALLOCSTAT )
!     IF ( ALLOCSTAT .NE. 0 ) THEN
!        XMSG = 'Failure allocating QV'
!        CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!     END IF
!
!     IF ( .NOT. INTERP3( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                    NCOLS * NROWS * NLAYS, QV ) ) THEN
      VARNM = 'QV'
!     IF ( .NOT. INTERP3( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                    NCOLS * NROWS * NLAYS, QV ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MDATE, MTIME, QV ) ) THEN
        XMSG = 'Could not read QV from ' // MET_CRO_3D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
      END IF

C...Get level heights / layer faces (m)
!     ALLOCATE ( ZF( MY_NCOLS,MY_NROWS,NLAYS ), STAT = ALLOCSTAT )
!     IF ( ALLOCSTAT .NE. 0 ) THEN
!        XMSG = 'Failure allocating ZF'
!        CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!     END IF
!
!
      VARNM = 'ZF'
!     IF ( .NOT. INTERP3 ( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                     NCOLS * NROWS * NLAYS, ZF ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MDATE, MTIME, ZF ) ) THEN
        XMSG = 'Could not read ZF from ' // MET_CRO_3D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
      END IF

!...Get mid-layer heights (m)
!
!     ALLOCATE ( ZH( MY_NCOLS,MY_NROWS,NLAYS ), STAT = ALLOCSTAT )
!     IF ( ALLOCSTAT .NE. 0 ) THEN
!        XMSG = 'Failure allocating ZH'
!        CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!     END IF
!
      VARNM = 'ZH'
!     IF ( .NOT. INTERP3 ( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                     NCOLS * NROWS * NLAYS, ZH ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MDATE, MTIME, ZH ) ) THEN
        XMSG = 'Could not read ZH from ' // MET_CRO_3D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
      END IF
!
!...Get pressure (Pa)
!
!     ALLOCATE ( PRES( MY_NCOLS,MY_NROWS,NLAYS ), STAT = ALLOCSTAT )
!     IF ( ALLOCSTAT .NE. 0 ) THEN
!        XMSG = 'Failure allocating PRES'
!        CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!     END IF
!
      VARNM = 'PRES'
!     IF ( .NOT. INTERP3( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                    NCOLS * NROWS * NLAYS, PRES ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MDATE, MTIME, PRES ) ) THEN
        XMSG = 'Could not read PRES from ' // MET_CRO_3D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
      END IF
!
!...compute layer thicknesses (m)
!
!     ALLOCATE ( DZZ( MY_NCOLS,MY_NROWS,NLAYS ), STAT = ALLOCSTAT )
!     IF ( ALLOCSTAT .NE. 0 ) THEN
!        XMSG = 'Failure allocating DZZ'
!        CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!     END IF
!
        DO row=1,my_nrows
          DO col=1,my_ncols
            dzz(col, row, 1) = zf(col, row, 1)
            DO lay=2,nlays
              dzz(col, row, lay) = zf(col, row, lay) - zf(col, row, lay-1)
            END DO
          END DO
        END DO
!
!...Get PBL height (m)
!
      VARNM = 'PBL'
      IF ( .NOT. INTERPX( MET_CRO_2D, VARNM, PNAME,
     &                    STRTCOLMC2,ENDCOLMC2, STRTROWMC2,ENDROWMC2, 1,1,
     &                    MDATE, MTIME, PBL ) ) THEN
        XMSG = 'Could not read PBL from ' // MET_CRO_2D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
      END IF
!
! set mdate:mtime to the hour
!
C...  on the input file are amounts within the metfiles timestep.

      IF ( .NOT. CURRSTEP( JDATE, JTIME, SDATE, STIME, MSTEP,
     &                     MDATE, MTIME ) ) THEN
        XMSG = 'Cannot get step-starting date and time'
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT3 )
      END IF

      CALL NEXTIME ( MDATE, MTIME, MSTEP )  ! set mdate:mtime to the hour

!...Get convective precipitation amount (cm)
!
!     ALLOCATE ( RC( MY_NCOLS,MY_NROWS ), STAT = ALLOCSTAT )
!     IF ( ALLOCSTAT .NE. 0 ) THEN
!        XMSG = 'Failure allocating RC'
!        CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!     END IF

      VARNM = 'RC'
!     IF ( .NOT. READ3( MET_CRO_2D, VARNM, ALLAYS3, MDATE, MTIME,
!    &                  RC ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_2D, VARNM, PNAME,
     &                    STRTCOLMC2,ENDCOLMC2, STRTROWMC2,ENDROWMC2, 1,1,
     &                    MDATE, MTIME, RC ) ) THEN
        XMSG = 'Could not read RC from ' // MET_CRO_2D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
        END IF
!
!...Convert the rainfall rate into mm/hr, then set a flag noting the
!...  presence of raining clouds if the rainfall is above the specified
!...  threshold
!
!      IF ( ICLDTYPE .EQ. 1 ) THEN
!
!       ALLOCATE ( RAIN( MY_NCOLS,MY_NROWS ), STAT = ALLOCSTAT )
!       IF ( ALLOCSTAT .NE. 0 ) THEN
!          XMSG = 'Failure allocating RAIN'
!          CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!       END IF
!
        DO row=1,my_nrows
          DO col=1,my_ncols
!
            rain(col, row) = 10.0*rc(col, row)/metstep
!
          END DO
        END DO
!
!  end loop on rows    ROW
!
!      END IF
!
!...Loop through all grid cells
!
        mmb=.false.
        DO row=1,my_nrows
!  end loop on columns COL
          DO 150 col=1,my_ncols
!
            clbase = nlays
!d        TOTFRAC( COL, ROW ) = 0.0
!d        ACTRNMA( COL, ROW ) = 0.0
!         CLBASE ( COL, ROW ) = NLAYS
!         CLTOPUSTBL( COL, ROW ) = NLAYS
!         QMAX  ( COL, ROW ) = 0.0
!         PLCL  ( COL, ROW ) = 0.0
!         SRCLAY( COL, ROW ) = NLAYS
            cltopustbl = nlays
!
		qmax=0.0
		plcl=0.
		srclay=nlays
            DO lay=1,nlays
!           QAD( COL, ROW, LAY ) = 0.0
              qad(lay) = 0.0
              presl(lay) = pres(col, row, lay)
              tal(lay) = ta(col, row, lay)
              qvl(lay) = qv(col, row, lay)
              dzzl(lay) = dzz(col, row, lay)
              densl(lay) = presl(lay)/(rdgas*tal(lay))
            END DO
!
!...load aerosol minimum concentrations into the "CONCMINL" array
!...  initialize all species to CMIN
!
!         CONCMINL = CMIN
            concminl = 1.0e-25
!
!...  set minimum for aerosol species
!
            spc = 0
            strt = ae_strt
            fini = ae_strt - 1 + n_ae_spc
            DO var=strt,fini
              spc = spc + 1
              DO lay=1,nlays
                concminl(var, lay) = aeconcmin(spc)/densl(lay)
              END DO
            END DO
!
            DO lay=1,nlays
              DO spc=1,nspcsd
                IF (cgrid(col, row, lay, spc) .LT. concminl(spc, lay)) THEN
                  CALL PUSHREAL4(conc(spc, lay))
                  conc(spc, lay) = concminl(spc, lay)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHREAL4(conc(spc, lay))
                  conc(spc, lay) = cgrid(col, row, lay, spc)
                  CALL PUSHCONTROL1B(1)
                END IF
              END DO
              CALL PUSHINTEGER4(spc - 1)
            END DO
!
!...first test for raining clouds
            IF (rain(col, row) .GE. rthresh) THEN
              icldtype = 1
            ELSE
              icldtype = 2
            END IF
! end of cld type test
!
            IF (icldtype .EQ. 1) THEN
!
!...if the rainfall amount is below the specified threshold, then set
!...  values for some of the parameters which will be used when the
!...  routine is called again for non-precipitating clouds...then
!...  skip to the next grid cell.
!
              prate = rain(col, row)
!           FRACMAX( COL, ROW ) = 0.0
!d          IRNFLAG( COL, ROW ) = 1
              fracmax = 0.0
!
            ELSE
!
!           FRACMAX( COL, ROW ) = 0.5
!d          IRNFLAG( COL, ROW ) = 0
              fracmax = 0.5
!
            END IF
!
!...Determine cloud source level by determining equivalent
!...   potential temperature profile given perturbed temperature
!...   and water vapor to account for local hot spots which
!...   initiate convection.  Layer with maximum equivalent
!...   potential temperature is cloud source layer.
!
            srclay = 1
            tmax = tal(1) + pert
            qmax = qvl(1) + perq
            pmax = presl(1)
            thmax = tmax*(100000.0/pmax)**rovcp
            eqthm = thmax*EXP(lvocp*qmax/tmax)
!         EQTHM = THMAX + ( LVOCP * QMAX * THMAX / TMAX )
!         WRITE( LOGDEV,* ) ' THMAX,EQTHM=',THMAX,EQTHM
!
            DO lay=2,nlays
!
              pp = presl(lay)
!
!           IF ( PP .LT. 65000.0 ) GO TO 223  !  loop exit
              IF (zh(col, row, lay) .GT. 3000.) THEN
                GOTO 223
              ELSE
!
                tp = tal(lay) + pert
                qp = qvl(lay) + perq
                thmax = tp*(100000.0/pp)**rovcp
                eqth = thmax*EXP(lvocp*qp/tp)
!           EQTH = THMAX + ( LVOCP * QP *THMAX/ TP )
!           WRITE( LOGDEV,* ) ' PP,TP,QP,THMAX,EQTH=',PP,TP,QP,THMAX,EQTH
!
                IF (eqth .GT. eqthm) THEN
!
                  tmax = tp
                  srclay = lay
                  qmax = qp
                  pmax = pp
                  eqthm = eqth
!
                END IF
              END IF
            END DO
!
!
!  loop exit target
!
!...Equivalent potential temp max is now known  between LAY 1
!...   and 650 mb. We now proceed to compute lifting condensation
!...   level.  First,  compute vapor pressure at the source level.
!...   Find dewpoint using empirical relationship, avoiding
!...   supersaturation.   Then compute dew point lapse rate -
!...   see Walcek and Taylor, 1986.
!
223       emax = qmax*pmax/(mvoma+qmax)
!??????
            tdmax = c302/(c303-ALOG(emax*vpinv))
            IF (tdmax .GT. tmax) THEN
              tdmax = tmax
            ELSE
              tdmax = tdmax
            END IF
            dplr = grav*tdmax*tdmax/(mvoma*lv0*tmax)
!         WRITE( LOGDEV,* ) ' SLAY,EQTHM,TDMAX,DPLR=',
!    &                  SRCLAY, EQTHM, TDMAX, DPLR
!
!...Compute difference between dry adiabatic and dew point lapse
!...   rate, height increment above source level to reach LCL,
!...   then calculate value of pressure at LCL.  Save result
!...   in DEP( *,*,N_SPC_WDEP+2 ).
!
            damdp = dalr - dplr
!
            IF (damdp .LE. 0.0) THEN
!
              plcl = pmax
!...walcek formula
              tlcl = tmax
!...walcek formula
!
            ELSE
!
              dzlcl = (tmax-tdmax)/damdp
!...walcek formula
              tlcl = tmax - dalr*dzlcl
!...walcek formula
!  midpt of TMAX, TLCL
              tbar = tmax - 0.5*dalr*dzlcl
              IF (tbar .LT. 150.0) THEN
                tbar = 150.0
              ELSE
                tbar = tbar
              END IF
              plcl = pmax*EXP(-(grav/rdgas*dzlcl/tbar))
              zlcl = dzlcl + zh(col, row, srclay)
!
            END IF
!
!         WRITE( LOGDEV,* ) ' SRCLAY=', SRCLAY
!
! if plcl < ptop or , or ...
!
!...Determine cloud base at LAY in  which LCL resides,
!...  but not below layer 2.
!
!...plcl above middle of top layer
!
            IF (presl(nlays) .GE. plcl) THEN
              plcl = presl(nlays)
              clbase = nlays
              WRITE(logdev, *) ' WARNING: PLCL above top: Continuing'
!
!...search loop to find CLBASE
!
            ELSE
!
              DO lay=2,nlays
                IF (presl(lay) .LE. plcl) GOTO 100
              END DO
!
! if you get here base never found
              clbase = nlays
              GOTO 245
100         clbase = lay
            END IF
!
!
!
!...CLBASE is LAY of LCL. Now, determine cloud top by following
!...   moist adiabat up from CLBASE. Assume a stable sounding
!...   (ISOUND=0) at first.  Moist adiabat solver calculates
!...   saturation temperatures TF at the full levels and TSAT( COL, ROW, LAY )
!...   at the half-levels, using a 2nd order Runge method employing
!...   temperatures and pressures at the quarter-levels.
!
245       isound = 0
            ad_count = 1
!  end loop following moist adiabat
            DO lay=clbase,nlays
!
!...walcek formulas
!
              dp = presl(lay-1) - presl(lay)
              pbar = presl(lay-1) - dp*0.5
              IF (lay .EQ. clbase) THEN
                dp = plcl - presl(lay)
                pbar = plcl - dp*0.5
                tbase = tlcl
              END IF
              IF (tbase - 0.00065*dp .LT. 150.0) THEN
                tbar = 150.0
              ELSE
                tbar = tbase - 0.00065*dp
              END IF
! Walcek's
              x1 = lv0*(mvoma*(vp0pa*EXP(c303-c302/tbar)/(pbar-vp0pa*EXP(c303-
     +         c302/tbar))))/(rdgas*tbar)
! original
! formulas
              dtdp = rdgas*tbar/(pbar*cpd)*((1.0+x1)/(1.0+0.622*lvocp/tbar*x1)
     +         )
              IF (tbase - dp*dtdp .LT. 150.0) THEN
                tsat(lay) = 150.0
              ELSE
                tsat(lay) = tbase - dp*dtdp
              END IF
              qad(lay) = mvoma*(vp0pa*EXP(c303-c302/tsat(lay))/(presl(lay)-
     +         vp0pa*EXP(c303-c302/tsat(lay))))
              tbase = tsat(lay)
!
!...end Walcek formulas
!
!...QAD is the moist adiabatic saturation mixing ratio, needed
!...  for the entrainment solver
!...  Now make choice on stability of sounding, comparing parcel
!...  temperature TSAT with environmental temperature TA.
!...  ISOUND is index for sounding stability. If ISOUND=0,
!...  moist adiabat never warmer than environment (stable).
!...  ISOUND=1, moist adiabat becomes warmer than environment
!...  (unstable).
!
              IF (isound .EQ. 0) THEN
                CALL PUSHCONTROL1B(0)
                IF (tsat(lay) .GT. tal(lay)) isound = 1
              ELSE
! cloud top determined by neutral bouyancy
! - 0.5 * PERT
                t1 = tsat(lay)
                IF (t1 .LT. tal(lay)) THEN
                  GOTO 110
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
              END IF
              ad_count = ad_count + 1
            END DO
            CALL PUSHCONTROL1B(0)
            CALL PUSHINTEGER4(ad_count)
!
!
!  if you get to here:  cloud stable or no top
            CALL PUSHINTEGER4(cltop)
            cltop = nlays - 1
            CALL PUSHCONTROL1B(1)
            GOTO 256
110       CALL PUSHCONTROL1B(1)
            CALL PUSHINTEGER4(ad_count)
            CALL PUSHINTEGER4(cltop)
            cltop = lay - 1
            CALL PUSHCONTROL1B(0)
!         IF( ICLDTYPE .EQ. 1 ) THEN
!             WRITE( XMSG, 91010 )
!    &             'Stable Precipitating cloud at COL= ',
!    &             COL, ' ROW= ',  ROW, ' ICLDTYPE= ', ICLDTYPE
!             CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT2 )
!           END IF
!
!
!...At this point, if ISOUND has not been set to 1, we have a
!...  "stable" cloud. In this case, we find cloud top by relative
!...   humidity criterion, or, not let cloud top go above 600mb.
!
256       IF (isound .EQ. 0) THEN
              IF (icldtype .NE. 1) THEN
                CALL PUSHCONTROL3B(1)
                GOTO 150
              ELSE
                CALL PUSHCONTROL1B(0)
!
                DO lay=clbase+1,nlays
                  IF (presl(lay) .LE. 60000.0) THEN
                    GOTO 120
                  ELSE
!  loop exit
                    rlh = qvl(lay)/(mvoma*(vp0pa*EXP(c303-c302/tal(lay))/(
     +               presl(lay)-vp0pa*EXP(c303-c302/tal(lay)))))
                    IF (rlh .LT. 0.65) GOTO 130
                  END IF
                END DO
!  to loop exit
!
!  if you get to here:  top never found
                cltop = nlays - 1
!
                GOTO 267
120           cltop = lay - 1
                GOTO 267
130           cltop = lay - 1
              END IF
            ELSE
              CALL PUSHCONTROL1B(1)
!
! store unstable cloud top
              cltopustbl = cltop
!
            END IF
!
!  loop exit target
!
!! end of existence, depth and frac cov calc for
!! either PFW or CNP clouds
!
267       IF (icldtype .EQ. 1) THEN
              CALL PUSHCONTROL1B(1)
            ELSE IF (zlcl .GT. pbl(col, row)) THEN
!  get cloud top for either CNP or PFW
!
              CALL PUSHCONTROL3B(2)
              GOTO 150
            ELSE
!
!...compute relative humidity at the cloud source level
!
              rlhsrc = qvl(srclay)/(mvoma*(vp0pa*EXP(c303-c302/tal(srclay))/(
     +         presl(srclay)-vp0pa*EXP(c303-c302/tal(srclay)))))
!
!           IF ( RLHSRC .LE. RCRIT1 ) GO TO 299
!
!...If all tests pass, then a CNP or PFW cloud exists
!...  Proceed to find CLTOP for CNP or PFW; don't allow
!...  cloud top to exceed 500mb, or, when RH falls below
!...  65%, cloud top found
!
!            DO LAY = CLBASE + 1, NLAYS
!              CLTOP = LAY - 1
!              RLH = QVL( LAY )
!     &            / QSAT( ESAT( TAL( LAY ) ), PRESL( LAY ) )
!              IF ( RLH .LT. 0.65 ) GO TO 285
!              IF ( PRESL( LAY ) .LE. 50000.0 ) GO TO 285
!            END DO
!
!285         CONTINUE   ! loop exit target, INITIAL cloud top found
!
!...Distiguish between CNP and PFW by whether rain is falling
!...  in the cell; if PFW, limit depth and find new CLTOP,
!...  else leave CLTOP alone
!
              IF (cltop .NE. clbase) THEN
! confine PFW to 1500 meters
                ctop = cltop
!
                DO lay=ctop,clbase,-1
                  IF (zh(col, row, lay) - zh(col, row, clbase) .LE. 3000.0)
     +             GOTO 140
                END DO
                GOTO 322
140           cltop = lay
              END IF
!
!
! exit target for PFW cloud
!
!...If unstable CNP or PFW, limit CLTOP to CLTOPUSTBL so that
!...  QAD profile is known through cloud depth for entrainment
!...  solver
!
322         IF (isound .EQ. 1) THEN
                IF (cltop .GT. cltopustbl) THEN
                  cltop = cltopustbl
                ELSE
                  cltop = cltop
                END IF
              END IF
!
!...Now compute fractional coverage for either CNP or PFW:
!
              IF (rlhsrc .GE. rcrit2) THEN
                CALL PUSHREAL4(frac)
                frac = fracmax
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREAL4(frac)
                frac = fracmax*((rlhsrc-rcrit1)/(rcrit2-rcrit1))
                CALL PUSHCONTROL1B(1)
              END IF
              IF (frac .LT. 0.01) THEN
                CALL PUSHCONTROL3B(3)
                GOTO 150
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
            END IF
!
!...Now cloud existence is established, initialize various
!...  variables needed for rest of computations
!
!...First, get moles air/m2 at each layer, initialize FSIDE
!
            DO lay=1,nlays
              CALL PUSHREAL4(rhom2(lay))
              rhom2(lay) = presl(lay)*dzzl(lay)*1.0e3/(rdgas*mwair*tal(lay))
              CALL PUSHREAL4(fside(lay))
              fside(lay) = 0.0
            END DO
!
            DO spc=1,nspcsd
! moles/m2 or mm*mol/lit scavenged
! ending equiv gas phase conc (moles/mole)
              CALL PUSHREAL4(cend(spc))
              cend(spc) = 0.0
! moles/m2 species below cloud
              bmol(spc) = 0.0
! moles/m2 species in cloud
              CALL PUSHREAL4(polc(spc))
              polc(spc) = 0.0
!
              DO lay=1,nlays
! below cloud weighting function
! moles sp/mole air in cloud
                CALL PUSHREAL4(pcld(spc, lay))
                pcld(spc, lay) = 0.0
              END DO
            END DO
            CALL PUSHINTEGER4(spc - 1)
!
!
!...compute no. of moles air below cloud base and inverse
!
            airmb0 = 0.0
            DO lay=1,clbase-1
              airmb0 = airmb0 + rhom2(lay)
            END DO
!
!...take the inverse
!
            CALL PUSHREAL4(airmbi)
            airmbi = 1.0/airmb0
!
!...below cloud base
!
            DO lay=1,clbase-1
!
!...   determine no. of moles/m2 of trace gas
!
              DO spc=1,nspcsd
                bmol(spc) = bmol(spc) + conc(spc, lay)*rhom2(lay)
              END DO
              CALL PUSHINTEGER4(spc - 1)
            END DO
            CALL PUSHINTEGER4(lay - 1)
!
!
!...determine average trace gas mixing ratio below cloud level
!
            DO spc=1,nspcsd
              cbase0(spc) = bmol(spc)*airmbi
              CALL PUSHREAL4(cbasef(spc))
              cbasef(spc) = cbase0(spc)
            END DO
            CALL PUSHINTEGER4(spc - 1)
!
!...Initialize variables needed for entrainment and in-cloud properties solver
!
! integrated excess water over grid cell nec. for rnout
            qxs = 0.0
! total air mass (moles/m2) in cloudy layers
            CALL PUSHREAL4(airm)
            airm = 0.0
! in-cloud average pressure
            CALL PUSHREAL4(pbarc)
            pbarc = 0.0
! cloud thickness (meters)
            cthk = 0.0
! condensed wat cont (kg/m2) integ. thru cloud depth
            CALL PUSHREAL4(wcbar)
            wcbar = 0.0
! total wat cont (kg/m2) integrated thru cloud depth
            CALL PUSHREAL4(wtbar)
            wtbar = 0.0
! cloud mean temp (K)
            CALL PUSHREAL4(tbarc)
            tbarc = 0.0
!
!...Determine condensed water content and entrainment at each cloud level
!...  Determine FSIDE profile for raining clouds; side entrainment
!...  only for PFW and CNP clouds
!
            IF (icldtype .EQ. 1) THEN
!! raining cloud
!
              IF (clbase .EQ. cltop) THEN
                CALL PUSHREAL4(fside(clbase))
                fside(clbase) = 1.0
                CALL PUSHCONTROL2B(2)
              ELSE
                ad_from = clbase
!
                DO lay=ad_from,cltop
!               FSIDE( LAY ) = SIDEFAC * ( CLTOP - LAY )
!     &                      / ( CLTOP - CLBASE )
                  CALL PUSHREAL4(fside(lay))
                  fside(lay) = 1.0
                END DO
                CALL PUSHINTEGER4(lay - 1)
                CALL PUSHINTEGER4(ad_from)
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE
              ad_from0 = clbase
!
!
!! then CNP or PFW
!
              DO lay=ad_from0,cltop
                CALL PUSHREAL4(fside(lay))
                fside(lay) = 1.0
              END DO
              CALL PUSHINTEGER4(lay - 1)
              CALL PUSHINTEGER4(ad_from0)
              CALL PUSHCONTROL2B(0)
            END IF
            ad_from1 = clbase
!
!
!...Use Warner profile to close system of conservation and
!...  thermodynamic equations solved iteratively, using Secant solver
!
            DO lay=ad_from1,cltop
              wl = 0.7*EXP((presl(lay)-plcl)*0.000125) + 0.2
!
              IF (lay .EQ. clbase) THEN
                p1 = 0.5*(presl(lay)+presl(lay-1))
!
                IF (plcl .LT. p1) THEN
                  p2 = 0.5*(presl(lay+1)+presl(lay))
                  p3 = (p2+plcl)*0.5
                  wl = 0.7*EXP((p3-plcl)*0.000125) + 0.2
                END IF
              END IF
!
!
!...original Walcek bisection solver
!
              qwat(lay) = wl*(qmax-qad(lay))
              IF (qwat(lay) .LT. 1.0e-20) THEN
                qwat(lay) = 1.0e-20
              ELSE
                qwat(lay) = qwat(lay)
              END IF
!
              tempa = tsat(lay) - 20.0
              tempb = tsat(lay) + 10.0
!
              qent = fside(lay)*qvl(lay) + (1.0-fside(lay))*qvl(cltop)
              xxxx = qent - qmax
              IF (xxxx .EQ. 0.0) xxxx = 1.0e-10
              CALL PUSHREAL4(f(lay))
              f(lay) = (mvoma*(vp0pa*EXP(c303-c302/tempa)/(presl(lay)-vp0pa*
     +         EXP(c303-c302/tempa)))+qwat(lay)-qmax)/xxxx
              IF (f(lay) .GT. 1.0) THEN
                f(lay) = 1.0
              ELSE
                f(lay) = f(lay)
              END IF
              IF (f(lay) .LT. 0.0) THEN
                f(lay) = 0.0
              ELSE
                f(lay) = f(lay)
              END IF
!
              ttop = tal(cltop)*(presl(lay)/presl(cltop))**rovcp
              tent = ttop*(1.0-fside(lay)) + tal(lay)*fside(lay)
!
              ti = tsat(lay)*(1.0-f(lay)) + tent*f(lay)
              dql = (qmax-qad(lay))*(1.0-f(lay)-wl)
              dqi = 0.0
!
              IF (tempa .LT. 273.15) THEN
                dqi = -(qwat(lay)*(tempa-273.15)/18.0)
                IF (tempa .LE. 255.15) dqi = qwat(lay)
              END IF
!
              fa = cpd*(tempa-ti) + lv0*dql + lf0*dqi
!
!...test for convergence, then cut the interval in half
!
              i599c = 0
!
!
599         htst = tempb - tempa
              IF (htst .GE. tst) THEN
                i599c = i599c + 1
!
                IF (i599c .GT. 1000) WRITE(xmsg, 91010)
     +                        'NO CONVERGENCE IN ENTRAINMENT SOLVER AT COL= '
     +                              , col, ' ROW= ', row, ' ICLDTYPE= ',
     +                              icldtype
!
                tempc = (tempa+tempb)*0.5
                qent = fside(lay)*qvl(lay) + (1.0-fside(lay))*qvl(cltop)
                xxxx = qent - qmax
                IF (xxxx .EQ. 0.0) xxxx = 1.0e-10
                f(lay) = (mvoma*(vp0pa*EXP(c303-c302/tempc)/(presl(lay)-vp0pa*
     +           EXP(c303-c302/tempc)))+qwat(lay)-qmax)/xxxx
                IF (f(lay) .GT. 0.99) THEN
                  f(lay) = 0.99
                ELSE
                  f(lay) = f(lay)
                END IF
                IF (f(lay) .LT. 0.01) THEN
                  f(lay) = 0.01
                ELSE
                  f(lay) = f(lay)
                END IF
                ttop = tal(cltop)*(presl(lay)/presl(cltop))**rovcp
                tent = ttop*(1.0-fside(lay)) + tal(lay)*fside(lay)
                ti = tsat(lay)*(1.0-f(lay)) + tent*f(lay)
                dql = (qmax-qad(lay))*(1.0-f(lay)-wl)
                dqi = 0.0
!
                IF (tempc .LT. 273.15) THEN
                  dqi = -(qwat(lay)*(tempc-273.15)/18.0)
                  IF (tempc .LE. 255.15) dqi = qwat(lay)
                END IF
!
                fb = cpd*(tempc-ti) + lv0*dql + lf0*dqi
!
                ftst = fa*fb
!
!...if fa*fb < 0 then zero lies between ta & tc
!...  if fa*fb > 0 then zero lies between tc & tb
!
                IF (ftst .GE. 0) THEN
                  IF (ftst .NE. 0) THEN
                    tempa = tempc
                    fa = fb
                    GOTO 599
                  END IF
                END IF
                tempb = tempc
                GOTO 599
              END IF
              IF (tempc .LT. 150.0) THEN
                tcld(lay) = 150.0
              ELSE
                tcld(lay) = tempc
              END IF
!
!...ice load in cloud is a function of temperature below freezing
!
              qice(lay) = 0.0
              IF (tcld(lay) .LT. 273.15) THEN
                qice(lay) = -(qwat(lay)*(tcld(lay)-273.15)/18.0)
                IF (tcld(lay) .LE. 255.15) qice(lay) = qwat(lay)
              END IF
!
!...After determining the ice fraction, compute the actual
!...  liquid water mixing ratio:
!
              qlqd(lay) = qwat(lay) - qice(lay)
!
!...compute the Liquid Water Content (LWC) by taking the
!...  product of the liquid wat mix ratio and the air density
!...  LWC in kg H2O per m**3 air:
!
              rhoair = presl(lay)/(rdgas*tcld(lay))
              lwc(lay) = qlqd(lay)*rhoair
              IF (5.0e-6 .LT. lwc(lay)) THEN
                lwc(lay) = lwc(lay)
              ELSE
                lwc(lay) = 5.0e-6
              END IF
! total water content
              twc = qwat(lay)*rhoair
!
!...Now perform vertical integration, weighting by liquid water
!...  content so that averaged quantities (used in Aqueous
!...  Chemistry) get the greatest weight where the liquid
!...  water content is greatest.
!
!...weighted cloud temp
!
              tbarc = tbarc + tcld(lay)*dzzl(lay)*lwc(lay)
!
!...weighted cloud pres
!
              pbarc = pbarc + presl(lay)*dzzl(lay)*lwc(lay)
!
!...integrated liquid water content (kg/m3)
!
              wcbar = wcbar + dzzl(lay)*lwc(lay)
!
!...integrated total water content
!
              wtbar = wtbar + dzzl(lay)*twc
! Cloud thickness
              cthk = cthk + dzzl(lay)
              IF (tcld(lay) .LT. tal(lay)) THEN
                t1 = tal(lay)
              ELSE
                t1 = tcld(lay)
              END IF
!
!...get saturation water vapor mixing ratio at that temp:
!
              qvc(lay) = mvoma*(vp0pa*EXP(c303-c302/t1)/(presl(lay)-vp0pa*EXP(
     +         c303-c302/t1)))
!
!...excess water is the sum of total condensed and saturated
!...  vapor minus grid cell average mixing ratio: QXS in kg/m2:
!...  integrated through cloud depth
!
              qxs = qxs + (qwat(lay)+qvc(lay)-qvl(lay))*rhoair*dzzl(lay)
!
!...get total air mass in cloudy layers:
!
              airm = airm + rhom2(lay)
            END DO
            CALL PUSHINTEGER4(lay - 1)
            CALL PUSHINTEGER4(ad_from1)
!
!
!...Now begin to split calculations for non-raining and raining
!...  clouds depending on inner loop index ICLDTYPE (1 = raining,
!...  2 = nonraining: either CNP of PFW:)
!
            IF (icldtype .EQ. 2) THEN
! no precip or excess water
              CALL PUSHREAL4(prate1)
              prate1 = 1.0e-30
              prate = 1.0e-30
              CALL PUSHCONTROL1B(0)
            ELSE
! branch for further CNP or PFW calculations
!
!...continue here for raining cloud...
!
!...get PRATE1, storm rainout rate in mm/hour, noting that 1kg
!...  of water occupies a 1mm thick layer of water in a square meter
!...  of ground (accounts for density of water = 1000kg/m3)
!
              CALL PUSHREAL4(prate1)
              prate1 = storme*qxs*3600.0/tclife
              IF (prate1 .LE. 1.001*prate) THEN
! Changed back to .999 - jp 6/05
                CALL PUSHREAL4(frac)
                frac = 0.999
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREAL4(frac)
                frac = prate/prate1
                CALL PUSHCONTROL1B(1)
              END IF
              IF (frac .LT. 0.01) THEN
                CALL PUSHCONTROL3B(4)
                GOTO 150
              ELSE
!
!...for raining cloud, compute water properties of interest
!...  below cloud base. First, parameterize total water content
!
! tot wat cont kg/m3
                twc = 0.067*prate**0.846/(frac*1000.0)
!
                DO lay=1,clbase-1
                  tcld(lay) = tal(lay)
                  rhoair = presl(lay)/(rdgas*tcld(lay))
! kg H2O / kg air
                  qwat(lay) = twc/rhoair
!
!...again partition into ice and liquid
!
                  qice(lay) = 0.0
!
                  IF (tcld(lay) .LT. 273.15) THEN
                    qice(lay) = -(qwat(lay)*(tcld(lay)-273.15)/18.0)
                    IF (tcld(lay) .LE. 255.15) qice(lay) = qwat(lay)
                  END IF
!
                  qlqd(lay) = qwat(lay) - qice(lay)
                  lwc(lay) = qlqd(lay)*rhoair
                  IF (0.000005 .LT. lwc(lay)) THEN
                    lwc(lay) = lwc(lay)
                  ELSE
                    lwc(lay) = 0.000005
                  END IF
                  pbarc = pbarc + presl(lay)*dzzl(lay)*lwc(lay)
                  tbarc = tbarc + tcld(lay)*dzzl(lay)*lwc(lay)
                  wcbar = wcbar + dzzl(lay)*lwc(lay)
                  wtbar = wtbar + dzzl(lay)*twc
                  cthk = cthk + dzzl(lay)
!
!...excess water is all rain
!
                  qxs = qxs + qwat(lay)*rhoair*dzzl(lay)
                END DO
!
!
!...Final calc of storm rainfall rate and frac area (RAINING CLDS)
!
                prate1 = storme*qxs*3600.0/tclife
!
                IF (prate1 .LE. 1.001*prate) THEN
! Changed back to .999 - jp 6/05
                  frac = 0.999
                  prate1 = prate/frac
                ELSE
                  frac = prate/prate1
                END IF
                IF (frac .LT. 0.01) THEN
                  CALL PUSHCONTROL3B(5)
                  GOTO 150
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
              END IF
            END IF
!
! target of cloudtype split
!
!...Begin mixing section, perform first for raining clouds using
!...  modified form of original Walcek mixing for RADM: mixing
!...  limited to 1 layer above cloud top; next for CNP or PFW clouds
!...  using direct exchange mixing mechanism by McHenry.
!
            DO spc=1,mxspcs
              DO lay=1,nlays
                ccr(spc, lay) = conc(spc, lay)
              END DO
              cbelow(spc) = cbase0(spc)
            END DO
!
!         IF ( ROW .EQ. 46 .AND. COL .EQ. 62 ) THEN
!           WRITE( LOGDEV, * ) ' BASE,TOP=',CLBASE,CLTOP,
!    &                         ' frac=',FRAC
!           WRITE( LOGDEV, * ) ' CB=',CBELOW(9),' PRATE,PRATE1=',PRATE,PRATE1
!           DO LAY = NLAYS, 1, -1
!             WRITE( LOGDEV, * ) LAY, TAL( LAY ),
!    &                           QVL( LAY ), PRESL( LAY ),
!    &                           ZH(COL, ROW, LAY ), ZF(COL, ROW, LAY ), CCR( 9, LAY )
!           END DO
!         END IF
!
            CALL PUSHINTEGER4(clbase)
            CALL PUSHREAL4ARRAY(sigf, nlays+1)
!slzx            if(icldtype.eq.1.and.clbase.gt.10) skipb(col,row) = .true.
            !slzbg if(icldtype.eq.1.and.maxval(f(clbase:cltop))/minval(f(clbase:cltop)).gt.70.) mmb(col,row) = .true.
            CALL ACMCLD(f, ccr, sigf, cbelow, clbase, cltop, frac, nspcsd,
     +           nlays, tclife, dtcld)
!
!         IF ( ROW .EQ. 46 .AND. COL .EQ. 62 ) THEN
!           WRITE( LOGDEV, * ) ' CBELOW=',CBELOW( 9 )
!           DO LAY = NLAYS, 1, -1
!             WRITE( LOGDEV, * ) ' Lay,c=',LAY, CCR( 9,LAY )
!           END DO
!         END IF
!
            DO spc=1,mxspcs
              CALL PUSHREAL4(cbasef(spc))
              cbasef(spc) = cbelow(spc)
            END DO
            ad_from2 = cltop
!
            DO lay=ad_from2,clbase,-1
              DO spc=1,nspcsd
                condis = conc(spc, lay)
                CALL PUSHREAL4(pcld(spc, lay))
                pcld(spc, lay) = f(lay)*(fside(lay)*condis) + (1.0-f(lay))*
     +           cbase0(spc)
                IF (pcld(spc, lay) .GT. ccr(spc, lay)/frac) THEN
                  pcld(spc, lay) = ccr(spc, lay)/frac
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                  pcld(spc, lay) = pcld(spc, lay)
                END IF
!
!...POLC in moles sp/m2
!
                CALL PUSHREAL4(polc(spc))
                polc(spc) = polc(spc) + pcld(spc, lay)*rhom2(lay)
              END DO
              CALL PUSHINTEGER4(spc - 1)
            END DO
            CALL PUSHINTEGER4(lay + 1)
            CALL PUSHINTEGER4(ad_from2)
!
!...Now compute for raining region below cloud which is also considered
!...  to be part of the aqueous reaction chamber
!
            DO lay=1,clbase-1
              airm = airm + rhom2(lay)
!
              DO spc=1,nspcsd
                IF (cbase0(spc) .EQ. 0.0) THEN
                  CALL PUSHREAL4(bcldwt(spc, lay))
                  bcldwt(spc, lay) = 1.0/clbase
                  CALL PUSHCONTROL1B(0)
                ELSE
                  IF (cbase0(spc) .LT. 1.0e-15) THEN
                    CALL PUSHREAL4(max1)
                    max1 = 1.0e-15
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHREAL4(max1)
                    max1 = cbase0(spc)
                    CALL PUSHCONTROL1B(1)
                  END IF
                  CALL PUSHREAL4(bcldwt(spc, lay))
                  bcldwt(spc, lay) = conc(spc, lay)/max1
                  CALL PUSHCONTROL1B(1)
                END IF
                CALL PUSHREAL4(pcld(spc, lay))
                pcld(spc, lay) = cbasef(spc)*bcldwt(spc, lay)
!...Necessary because CBASEF and CBASE0 are the ending vertical averages
!...  below cloud concentrations in moles sp/mole air
!
                IF (icldtype .EQ. 1) THEN
                  CALL PUSHREAL4(polc(spc))
                  polc(spc) = polc(spc) + pcld(spc, lay)*rhom2(lay)
                  CALL PUSHCONTROL1B(1)
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
              END DO
              CALL PUSHINTEGER4(spc - 1)
            END DO
            CALL PUSHINTEGER4(lay - 1)
            IF (airm .LT. 1.0e-30) THEN
              airm = 1.0e-30
            ELSE
              airm = airm
            END IF
            IF (wcbar .LT. 1.0e-30) THEN
              wcbar = 1.0e-30
            ELSE
              wcbar = wcbar
            END IF
            IF (wtbar .LT. 1.0e-30) THEN
              wtbar = 1.0e-30
            ELSE
              wtbar = wtbar
            END IF
            IF (cthk .LT. 1.0e-30) THEN
              cthk = 1.0e-30
            ELSE
              cthk = cthk
            END IF
!
! deg K (note WCBAR has hidden
! factor CTHK in it)
            tbarc = tbarc/wcbar
! ave cloud pres, Pa
            pbarc = pbarc/wcbar
!
! ave liq wat content in kg/m3
            wcbar = wcbar/cthk
!
! ave con wat content in kg/m3
            wtbar = wtbar/cthk
!
!...Finally, get in cloud pollutant concentrations in moles sp
!...  per mole air
!
            DO spc=1,nspcsd
!           POLC ( SPC ) = MAX( POLC( SPC ) / AIRM, 1.0E-30 )
              CALL PUSHREAL4(polc(spc))
              polc(spc) = polc(spc)/airm
              CALL PUSHREAL4(cend(spc))
              cend(spc) = polc(spc)
            END DO
            CALL PUSHINTEGER4(spc - 1)
!
!
            arpres = pbarc/stdatmpa
            rtch = molvol/stdtemp*tbarc
            CALL PUSHREAL4(cthk1)
            cthk1 = airm*rtch/(arpres*1000.0)
!
            CALL PUSHINTEGER4(tr_strt)
            CALL PUSHINTEGER4(ae_strt)
            CALL PUSHINTEGER4(gc_strt)
            CALL PUSHINTEGER4(nspcsd)
            CALL PUSHINTEGER4(nr_strt)
            CALL PUSHREAL4(alfa3)
            CALL PUSHREAL4(alfa2)
            CALL PUSHREAL4(alfa0)
            CALL PUSHREAL4ARRAY(cend, 137)
            CALL SCAVWDEP(jdate, jtime, wtbar, wcbar, tbarc, pbarc, cthk1,
     +                airm, prate1, dtcld, polc, cend, remov, removac, alfa0
     +                , alfa2, alfa3)
!
!...if the liquid water content is above the specified threshold
!...  then perform the aqueous chemistry within the cloud and
!...  re-adjust the ending and removed amounts for those species
!...  that participated in cloud chemistry
!
            IF (wcbar .GT. 0.00001) THEN
!
              CALL PUSHINTEGER4(tr_strt)
              CALL PUSHINTEGER4(ae_strt)
              CALL PUSHINTEGER4(gc_strt)
              CALL PUSHINTEGER4(nr_strt)
              CALL PUSHREAL4ARRAY(cend, 137)
              CALL AQ_MAP(jdate, jtime, wtbar, wcbar, tbarc, pbarc, cthk1,
     +                airm, prate1, dtcld, polc, cend, remov, removac, alfa0
     +                , alfa2, alfa3)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
!
!...Compute concentration changes in the grid column resulting
!...  from subgrid scale vertical mixing:
!
!...first, below cloud base,
!...   include raining region below cld base
!
            DO lay=1,clbase-1
              DO spc=1,nspcsd
                IF (icldtype .EQ. 1) THEN
                  IF (polc(spc) .LT. concminl(spc, lay)) THEN
                    CALL PUSHREAL4(max2)
                    max2 = concminl(spc, lay)
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHREAL4(max2)
                    max2 = polc(spc)
                    CALL PUSHCONTROL1B(1)
                  END IF
! raining cloud:
                  IF (spc .NE. n_gc_spcd) THEN
                    CALL PUSHCONTROL2B(2)
                  ELSE
                    CALL PUSHCONTROL2B(1)
                  END IF
                ELSE
                  CALL PUSHCONTROL2B(0)
                END IF
              END DO
              CALL PUSHINTEGER4(spc - 1)
            END DO
            CALL PUSHINTEGER4(lay - 1)
            ad_from3 = clbase
!
!...Now do changes in cloudy layers :
!
            DO lay=ad_from3,cltop
              DO spc=1,nspcsd
                IF (polc(spc) .LT. concminl(spc, lay)) THEN
                  CALL PUSHREAL4(max3)
                  max3 = concminl(spc, lay)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHREAL4(max3)
                  max3 = polc(spc)
                  CALL PUSHCONTROL1B(1)
                END IF
                outcloud(spc, lay) = (ccr(spc, lay)-pcld(spc, lay)*frac)/(1.0-
     +           frac)
                IF (outcloud(spc, lay) .LT. concminl(spc, lay)) THEN
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
                IF (spc .NE. n_gc_spcd) THEN
                  CALL PUSHCONTROL1B(1)
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
              END DO
              CALL PUSHINTEGER4(spc - 1)
            END DO
            CALL PUSHINTEGER4(lay - 1)
            CALL PUSHINTEGER4(ad_from3)
            CALL PUSHCONTROL3B(0)
150      CONTINUE
        END DO
        incloudb = 0.0
        polcb = 0.0
        bcldwtb = 0.0
        bmolb = 0.0
        ccrb = 0.0
        cbase0b = 0.0
        alfa0b = 0.0
        alfa2b = 0.0
        alfa3b = 0.0
        cbelowb = 0.0
        outcloudb = 0.0
        pcldb = 0.0
        cendb = 0.0
        cbasefb = 0.0
        concb = 0.0
        DO row=my_nrows,1,-1
          DO col=my_ncols,1,-1
            concbchk = 0.
            CALL POPCONTROL3B(branch)
            IF (branch .LT. 3) THEN
              IF (branch .EQ. 0) THEN
                CALL POPINTEGER4(ad_from3)
                CALL POPINTEGER4(ad_to15)
                DO lay=ad_to15,ad_from3,-1
                  CALL POPINTEGER4(ad_to14)
                  DO spc=ad_to14,1,-1
                    CALL POPCONTROL1B(branch)
                    IF (branch .NE. 0) THEN
                      incloudb(spc, lay) = incloudb(spc, lay) + frac*cgridb(
     +                 col, row, lay, spc)
                      outcloudb(spc, lay) = outcloudb(spc, lay) + (1.0-frac)*
     +                 cgridb(col, row, lay, spc)
                      cgridb(col, row, lay, spc) = 0.0
                    END IF
                    CALL POPCONTROL1B(branch)
                    IF (branch .EQ. 0) outcloudb(spc, lay) = 0.0
                    temp0 = cend(spc)/max3
                    tempb1 = outcloudb(spc, lay)/(1.0-frac)
                    ccrb(spc, lay) = ccrb(spc, lay) + tempb1
!slz                    pcldb(spc, lay) = pcldb(spc, lay) + temp0*incloudb(spc,
!slz     +               lay) - frac*tempb1
                    pcldb(spc, lay) = pcldb(spc, lay) - frac*tempb1

                    outcloudb(spc, lay) = 0.0
                    tempb2 = onedp*pcld(spc, lay)*incloudb(spc, lay)/max3

                    cendb(spc) = cendb(spc) + tempb2

                    max3b = -(temp0*tempb2)
                    incloudb(spc, lay) = 0.0
                    CALL POPCONTROL1B(branch)
                    CALL POPREAL4(max3)
                    IF (branch .NE. 0) THEN
                      polcb(spc) = polcb(spc) !slz + max3b
                    END IF
                  END DO
                END DO
                CALL POPINTEGER4(ad_to13)
                DO lay=ad_to13,1,-1
                  CALL POPINTEGER4(ad_to12)
                  DO spc=ad_to12,1,-1
                    CALL POPCONTROL2B(branch)
                    IF (branch .EQ. 0) THEN
                      pcldb(spc, lay) = pcldb(spc, lay) + cgridb(col, row, lay
     +                 , spc)
                      cgridb(col, row, lay, spc) = 0.0
                    ELSE
                      IF (branch .NE. 1) THEN
                        incloudb(spc, lay) = incloudb(spc, lay) + frac*cgridb(
     +                   col, row, lay, spc)
                        outcloudb(spc, lay) = outcloudb(spc, lay) + (1.0-frac)
     +                   *cgridb(col, row, lay, spc)
                        cgridb(col, row, lay, spc) = 0.0
                      END IF
                      temp = cend(spc)/max2
!slz                      pcldb(spc, lay) = pcldb(spc, lay) + temp*incloudb(spc,
!slz     +                 lay) + outcloudb(spc, lay)
                      pcldb(spc, lay) = pcldb(spc, lay) + outcloudb(spc, lay)
                      outcloudb(spc, lay) = 0.0
                      tempb0 = onedp*pcld(spc, lay)*incloudb(spc, lay)/max2
                      cendb(spc) = cendb(spc) + tempb0
                      max2b = -(temp*tempb0)
                      incloudb(spc, lay) = 0.0
                      CALL POPCONTROL1B(branch)
                      IF (branch .EQ. 0) THEN
                        CALL POPREAL4(max2)
                      ELSE
                        CALL POPREAL4(max2)
                        polcb(spc) = polcb(spc) !slz + max2b
                      END IF
                    END IF
                  END DO
                END DO
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPREAL4ARRAY(cend, 137)
                  CALL POPINTEGER4(nr_strt)
                  CALL POPINTEGER4(gc_strt)
                  CALL POPINTEGER4(ae_strt)
                  CALL POPINTEGER4(tr_strt)
                  CALL AQ_MAP_B(jdate, jtime, wtbar, wcbar, tbarc, pbarc,
     +                   cthk1, airm, prate1, dtcld, polc, polcb, cend, cendb
     +                   , remov, removac, alfa0, alfa0b, alfa2, alfa2b,
     +                   alfa3, alfa3b)
                END IF
                CALL POPREAL4ARRAY(cend, 137)
                CALL POPREAL4(alfa0)
                CALL POPREAL4(alfa2)
                CALL POPREAL4(alfa3)
                CALL POPINTEGER4(nr_strt)
                CALL POPINTEGER4(nspcsd)
                CALL POPINTEGER4(gc_strt)
                CALL POPINTEGER4(ae_strt)
                CALL POPINTEGER4(tr_strt)
                CALL SCAVWDEP_B(jdate, jtime, wtbar, wcbar, tbarc, pbarc,
     +                   cthk1, airm, prate1, dtcld, polc, polcb, cend, cendb
     +                   , remov, removac, alfa0, alfa0b, alfa2, alfa2b,
     +                   alfa3, alfa3b)
                CALL POPREAL4(cthk1)
                CALL POPINTEGER4(ad_to11)
                DO spc=ad_to11,1,-1
                  CALL POPREAL4(cend(spc))
                  polcb(spc) = polcb(spc) + cendb(spc)
                  cendb(spc) = 0.0
                  CALL POPREAL4(polc(spc))
                  polcb(spc) = polcb(spc)/airm
                END DO
                CALL POPINTEGER4(ad_to10)
                DO lay=ad_to10,1,-1
                  CALL POPINTEGER4(ad_to9)
                  DO spc=ad_to9,1,-1
                    CALL POPCONTROL1B(branch)
                    IF (branch .NE. 0) THEN
                      CALL POPREAL4(polc(spc))
                      pcldb(spc, lay) = pcldb(spc, lay) + rhom2(lay)*polcb(spc
     +                 )
                      concbchk(spc,lay) = concbchk(spc,lay) + pcldb(spc,lay) !slz
                    END IF
                    CALL POPREAL4(pcld(spc, lay))
                    cbasefb(spc) = cbasefb(spc) + bcldwt(spc, lay)*pcldb(spc,
     +               lay)
                    bcldwtb(spc, lay) = bcldwtb(spc, lay) !slz + cbasef(spc)*pcldb(
!slz      +               spc, lay)
                    pcldb(spc, lay) = 0.0
                    CALL POPCONTROL1B(branch)
                    IF (branch .EQ. 0) THEN
                      CALL POPREAL4(bcldwt(spc, lay))
                      bcldwtb(spc, lay) = 0.0
                    ELSE
                      CALL POPREAL4(bcldwt(spc, lay))
                      concb(spc, lay) = concb(spc, lay) + bcldwtb(spc, lay)/
     +                 max1
                      max1b = -(onedp*conc(spc, lay)*bcldwtb(spc, lay)/(onedp*max1)**2)
                      bcldwtb(spc, lay) = 0.0
                      CALL POPCONTROL1B(branch)
                      IF (branch .EQ. 0) THEN
                        CALL POPREAL4(max1)
                      ELSE
                        CALL POPREAL4(max1)
                        cbase0b(spc) = cbase0b(spc) + max1b
                      END IF
                    END IF
                  END DO
                END DO
                CALL POPINTEGER4(ad_from2)
                CALL POPINTEGER4(ad_to8)
!slz discard _b from acmcld , tag slzx
                DO lay=ad_to8,ad_from2,1
                  CALL POPINTEGER4(ad_to7)
                  DO spc=ad_to7,1,-1
                    CALL POPREAL4(polc(spc))
                    pcldb(spc, lay) = pcldb(spc, lay) + rhom2(lay)*polcb(spc)
                    CALL POPCONTROL1B(branch)
                    IF (branch .EQ. 0) THEN
                      ccrb(spc, lay) = ccrb(spc, lay) + pcldb(spc, lay)/frac
                      pcldb(spc, lay) = 0.0
                    END IF
                    CALL POPREAL4(pcld(spc, lay))
                    condisb = fside(lay)*f(lay)*pcldb(spc, lay)
                    cbase0b(spc) = cbase0b(spc) + (1.0-f(lay))*pcldb(spc, lay)
                    pcldb(spc, lay) = 0.0
                    concb(spc, lay) = concb(spc, lay) + condisb
                  END DO
                END DO
                DO spc=mxspcs,1,-1
                  CALL POPREAL4(cbasef(spc))
                  cbelowb(spc) = cbelowb(spc) + cbasefb(spc)
                  cbasefb(spc) = 0.0
                END DO
                CALL POPREAL4ARRAY(sigf, nlays+1)
                CALL POPINTEGER4(clbase)
                CALL ACMCLD_B(f, ccr, ccrb, sigf, cbelow, cbelowb, clbase,
     +                 cltop, frac, nspcsd, nlays, tclife, dtcld)
                DO spc=mxspcs,1,-1
                  concbchkmin_int(spc)=minval(concbchk(spc,:)/dzzl(:))
                  concbchkmax_int(spc)=maxval(concbchk(spc,:)/dzzl(:))
                  cbase0b(spc) = cbase0b(spc) + cbelowb(spc)
                  cbelowb(spc) = 0.0
                  DO lay=nlays,1,-1
                    concbchkmin(spc,lay)=concbchkmin_int(spc)*dzzl(lay)
                    concbchkmax(spc,lay)=concbchkmax_int(spc)*dzzl(lay)
                    concb(spc, lay) = concb(spc, lay) + ccrb(spc, lay)
                    if(mmb(col,row)) then !slzx
                     concb(spc, lay) = max(concbchkmin(spc,lay),concb(spc,lay))
                     concb(spc, lay) = min(concbchkmax(spc,lay),concb(spc,lay))
                    end if
                    ccrb(spc, lay) = 0.0
                  END DO
                END DO
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPREAL4(prate1)
                  GOTO 160
                END IF
              ELSE IF (branch .EQ. 1) THEN
                GOTO 190
              ELSE
                GOTO 180
              END IF
            ELSE IF (branch .EQ. 3) THEN
              GOTO 170
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL4(frac)
            ELSE
              CALL POPREAL4(frac)
            END IF
            CALL POPREAL4(prate1)
160       CALL POPINTEGER4(ad_from1)
            CALL POPINTEGER4(ad_to6)
            DO lay=ad_to6,ad_from1,-1
              CALL POPREAL4(f(lay))
            END DO
            CALL POPCONTROL2B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPINTEGER4(ad_from0)
              CALL POPINTEGER4(ad_to5)
              DO lay=ad_to5,ad_from0,-1
                CALL POPREAL4(fside(lay))
              END DO
            ELSE IF (branch .EQ. 1) THEN
              CALL POPINTEGER4(ad_from)
              CALL POPINTEGER4(ad_to4)
              DO lay=ad_to4,ad_from,-1
                CALL POPREAL4(fside(lay))
              END DO
            ELSE
              CALL POPREAL4(fside(clbase))
            END IF
            CALL POPREAL4(tbarc)
            CALL POPREAL4(wtbar)
            CALL POPREAL4(wcbar)
            CALL POPREAL4(pbarc)
            CALL POPREAL4(airm)
            CALL POPINTEGER4(ad_to3)
            DO spc=ad_to3,1,-1
              CALL POPREAL4(cbasef(spc))
              cbase0b(spc) = cbase0b(spc) + cbasefb(spc)
              cbasefb(spc) = 0.0
              bmolb(spc) = bmolb(spc) + airmbi*cbase0b(spc)
              cbase0b(spc) = 0.0
            END DO
            CALL POPINTEGER4(ad_to2)
            DO lay=ad_to2,1,-1
              CALL POPINTEGER4(ad_to1)
              DO spc=ad_to1,1,-1
               concb(spc, lay) = concb(spc, lay) + rhom2(lay)*bmolb(spc)
               if(mmb(col,row)) then !slzx
                concb(spc, lay) = max(concbchkmin(spc,lay),concb(spc,lay))
                concb(spc, lay) = min(concbchkmax(spc,lay),concb(spc,lay))
               end if
              END DO
            END DO
            CALL POPREAL4(airmbi)
            CALL POPINTEGER4(ad_to0)
            DO spc=ad_to0,1,-1
              DO lay=nlays,1,-1
                CALL POPREAL4(pcld(spc, lay))
                pcldb(spc, lay) = 0.0
                bcldwtb(spc, lay) = 0.0
              END DO
              CALL POPREAL4(polc(spc))
              polcb(spc) = 0.0
              bmolb(spc) = 0.0
              CALL POPREAL4(cend(spc))
              cendb(spc) = 0.0
            END DO
            DO lay=nlays,1,-1
              CALL POPREAL4(fside(lay))
              CALL POPREAL4(rhom2(lay))
            END DO
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) GOTO 180
170       CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL4(frac)
            ELSE
              CALL POPREAL4(frac)
            END IF
180       CALL POPCONTROL1B(branch)
190       CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPINTEGER4(cltop)
            ELSE
              CALL POPINTEGER4(cltop)
            END IF
            CALL POPINTEGER4(ad_count)
            DO i=1,ad_count
              IF (i .EQ. 1) THEN
                CALL POPCONTROL1B(branch)
              ELSE
                CALL POPCONTROL1B(branch)
              END IF
            END DO
            DO lay=nlays,1,-1
              CALL POPINTEGER4(ad_to)
              DO spc=ad_to,1,-1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPREAL4(conc(spc, lay))
                  concb(spc, lay) = 0.0
                ELSE
                  CALL POPREAL4(conc(spc, lay))
                  cgridb(col, row, lay, spc) = cgridb(col, row, lay, spc) +
     +             concb(spc, lay)
                  concb(spc, lay) = 0.0
                END IF
              END DO
            END DO
          END DO
        END DO
        CALL POPCONTROL1B(branch)
200     return  
!slz        CALL POPCONTROL1B(branch)
!slz        IF (branch .EQ. 0) THEN
!slz          DEALLOCATE(sigf)
!slz          DEALLOCATE(sigfb)
!slz        END IF
!
91010      FORMAT(3(a,:,i3,:))
      END SUBROUTINE CONVCLD_ACM_B
