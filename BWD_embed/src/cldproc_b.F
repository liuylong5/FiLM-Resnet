!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of cldproc in reverse (adjoint) mode:
!   gradient     of useful results: *tot_dep *conv_dep cgrid
!   with respect to varying inputs: cgrid
!
!***********************************************************************
!   Portions of Models-3/CMAQ software were developed or based on      *
!   information from various groups: Federal Government employees,     *
!   contractors working on a United States Government contract, and    *
!   non-Federal sources (including research institutions).  These      *
!   research institutions have given the Government permission to      *
!   use, prepare derivative works, and distribute copies of their      *
!   work in Models-3/CMAQ to the public and to permit others to do     *
!   so.  EPA therefore grants similar permissions for use of the       *
!   Models-3/CMAQ software, but users are requested to provide copies  *
!   of derivative works to the Government without restrictions as to   *
!   use by others.  Users are responsible for acquiring their own      *
!   copies of commercial software associated with Models-3/CMAQ and    *
!   for complying with vendor requirements.  Software copyrights by    *
!   the MCNC Environmental Modeling Center are used with their         *
!   permissions subject to the above restrictions.                     *
!***********************************************************************
!
! RCS file, release, date & time of last delta, author, state, [and locker]
! $Header: /project/work/rep/CCTM/src/cloud/cloud_acm_ae5/cldproc_acm.F,v 1.5 2009/12/09 17:40:03 sjr Exp $
!
! what(1) key, module and SID; SCCS file; date and time of last delta:
! %W% %P% %G% %U%
!
!:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      SUBROUTINE CLDPROC_BWD(cgridb, jdate, jtime, tstep)
        USE GRID_CONF
        USE CGRID_SPCS
        USE CHK_FILES_DEFS        ! adjoint checkpoint files definition
        USE CHK_FILES             ! adjoint checkpoint files routines

        IMPLICIT NONE

C...........INCLUDES

      INCLUDE SUBST_IOPARMS          ! I/O parameters definitions
      INCLUDE SUBST_IOFDESC          ! file header data structure
#include      SUBST_IODECL
#ifdef Incl
      INCLUDE SUBST_GC_SPC           ! gas chemistry species table
      INCLUDE SUBST_GC_WDEP          ! wet deposition table for gases
      INCLUDE SUBST_AE_SPC           ! aerosol species table
      INCLUDE SUBST_AE_WDEP          ! wet deposition table for aerosols
      INCLUDE SUBST_NR_SPC           ! non-reactive species table
      INCLUDE SUBST_NR_WDEP          ! wet deposition table for non-reactives
      INCLUDE SUBST_TR_SPC           ! tracer species table
      INCLUDE SUBST_TR_WDEP          ! wet deposition table for tracers
#endif

      INCLUDE SUBST_CONST            ! constants
      INCLUDE SUBST_FILES_ID         ! file name parameters

      CHARACTER(len=120) :: xmsg=' '
!
!...........PARAMETERS
!
! # of wet deposition species
!
        INTEGER, PARAMETER :: n_spc_wdep=n_gc_wdep+n_ae_wdep+n_nr_wdep+n_tr_wdep
        INTEGER, PARAMETER :: n_spc_wdepd=n_spc_wdep+1
!
!
        REAL, PARAMETER :: cnv1=mwair*1.0e-9
        REAL, PARAMETER :: cnv1i=1.0/cnv1
        REAL, PARAMETER :: cnv2=mwair*1.0e-3
        REAL, PARAMETER :: cnv2i=1.0/cnv2
!     REAL, PARAMETER :: CNV3 = MWAIR * 1.0E+3 / AVO  ! -> ppmV
!     REAL, PARAMETER :: CNV3 = CNV2 / AVO            ! -> mol/mol
! -> #/mol
        REAL, PARAMETER :: cnv3=cnv2
        REAL, PARAMETER :: cnv3i=1.0/cnv3
!
!...........ARGUMENTS
!
!     REAL          CGRID( NCOLS, NROWS, NLAYS, * )  ! concentrations
! concentrations
        REAL,ALLOCATABLE, SAVE :: cgrid(:, :, :, :)
        REAL, POINTER :: cgridb(:, :, :, :)
!      REAL, POINTER :: CGRID( :,:,:,: )                 ! concentrations
! current model date, coded YYYYDDD
        INTEGER :: jdate
! current model time, coded HHMMSS
        INTEGER :: jtime
! model time step, coded HHMMSS
        INTEGER :: tstep(2)
!
!...........Local Variables
!
! flag for first pass thru
        LOGICAL, SAVE :: firstime=.true.
!
! flag to output cloud diagnostic files
        LOGICAL, SAVE :: cld_diag
!
! driver program name
        CHARACTER(len=16), SAVE :: pname='CLDPROC_b'
! input variable name list
        CHARACTER(len=16) :: vname
!
! column subscript indices
        INTEGER :: col
! ending position
        INTEGER :: fini
! 1: raining, 2: either CNP or PFW
        INTEGER :: icldtype
! loop counter
        INTEGER :: l
! layer subscript indices
        INTEGER :: lay
! middle of this time step
        INTEGER :: mdate
! middle of this time step
        INTEGER :: mtime
! middle of this time step
        INTEGER :: ndate
! middle of this time step
        INTEGER :: ntime
! number of #/m3 species
        INTEGER, SAVE :: nnae
! number of ug/m3 species
        INTEGER, SAVE :: nqae
! number of m2/m3 species
        INTEGER, SAVE :: nsae
! row subscript indices
        INTEGER :: row
! species subscript indices
        INTEGER :: spc
! starting position
        INTEGER :: strt
!  ENVINT status
        INTEGER :: status
! variable subscript indices
        INTEGER :: var
        INTEGER :: allocstat
!
! wet deposition map to CGRID
        INTEGER, SAVE :: wdep_map(n_spc_wdepd)
! CGRID pointer to ug/m3 species
        INTEGER, SAVE :: qae(n_ae_spcd)
! CGRID pointer to #/m3 species
        INTEGER, SAVE :: nae(n_ae_spcd)
! CGRID pointer to m2/m3 species
        INTEGER, SAVE :: sae(n_ae_spcd)
!
!
! output log unit number
        INTEGER, SAVE :: logdev
!
!
!     REAL          DENS    ( NCOLS,NROWS,NLAYS ) ! air density (kg/m3)
!     REAL          CONV_DEP( NCOLS,NROWS,N_SPC_WDEP+8 ) ! convective wdep only
!     REAL          TOT_DEP ( NCOLS,NROWS,N_SPC_WDEP+1 ) ! total wdep
! air density (kg/m3)
        REAL, ALLOCATABLE, SAVE :: dens(:, :, :)
! convective wdep only
        REAL, ALLOCATABLE, SAVE :: conv_dep(:, :, :)
! total wdep
        REAL, ALLOCATABLE, SAVE :: tot_dep(:, :, :)
!
! temp conversion factor
        REAL :: fac
        REAL :: ccmin
        REAL :: ccminb
!
! global origin offset from file
        INTEGER :: gxoff, gyoff
! for INTERPX
        INTEGER, SAVE :: strtcolmc3, endcolmc3, strtrowmc3, endrowmc3
!
!...........EXTERNAL FUNCTIONS
!
        LOGICAL, EXTERNAL :: ENVYN
        EXTERNAL M3MESG
        EXTERNAL SUBHFILE
        LOGICAL :: result1
        LOGICAL :: res
        LOGICAL :: res0
        LOGICAL :: res1
        LOGICAL :: res2
        LOGICAL :: res3
        LOGICAL :: res4
        LOGICAL :: res5
        LOGICAL :: res6
        INTEGER :: ad_from
        INTEGER :: ad_to
        INTEGER :: branch
        INTEGER :: ad_from0
        INTEGER :: ad_to0
        INTEGER :: ad_from1
        INTEGER :: ad_to1
        INTEGER :: ad_from2
        INTEGER :: ad_to2
        INTEGER :: ad_from3
        INTEGER :: ad_to3
        INTEGER :: ad_from4
        INTEGER :: ad_to4
        INTEGER :: ad_from5
        INTEGER :: ad_to5
        INTEGER :: ad_from6
        INTEGER :: ad_to6
        INTEGER :: ad_from7
        INTEGER :: ad_to7
        INTEGER :: ad_from8
        INTEGER :: ad_to8
        INTEGER :: ad_from9
        INTEGER :: ad_to9
        INTRINSIC MAX
        INTRINSIC INDEX
        INTERFACE
            SUBROUTINE RESCLD_B(cgrid, cgridb, jdate, jtime, tstep, n_spc_wdep
     +        , wdep_map, dep)
!            REAL, POINTER          :: CGRID( :,:,:,: )
              REAL :: cgrid(:, :, :, :)
              REAL, POINTER :: cgridb(:, :, :, :)
              INTEGER, INTENT(IN) :: jdate, jtime, tstep(2)
              INTEGER, INTENT(IN) :: n_spc_wdep
              INTEGER, INTENT(IN) :: wdep_map(:)
              REAL, INTENT(OUT) :: dep(:, :, :)
            END SUBROUTINE RESCLD_B
            SUBROUTINE CONVCLD_ACM_B(cgrid, cgridb, jdate, jtime, tstep,
     +        n_spc_wdep, wdep_map, dep)
!            REAL, POINTER          :: CGRID( :,:,:,: )
              REAL :: cgrid(:, :, :, :)
              REAL, POINTER :: cgridb(:, :, :, :)
              INTEGER :: jdate, jtime, tstep(2)
              INTEGER :: n_spc_wdep
              INTEGER :: wdep_map(:)
              REAL :: dep(:, :, :)
            END SUBROUTINE CONVCLD_ACM_B
        END INTERFACE

        INTERFACE
            SUBROUTINE RESCLD(cgrid, jdate, jtime, tstep, n_spc_wdep, wdep_map
     +        , dep)
!            REAL, POINTER          :: CGRID( :,:,:,: )
              REAL :: cgrid(:, :, :, :)
              INTEGER, INTENT(IN) :: jdate, jtime, tstep(2)
              INTEGER, INTENT(IN) :: n_spc_wdep
              INTEGER, INTENT(IN) :: wdep_map(:)
              REAL, INTENT(OUT) :: dep(:, :, :)
            END SUBROUTINE RESCLD
            SUBROUTINE CONVCLD_ACM(cgrid, jdate, jtime, tstep, n_spc_wdep,
     +        wdep_map, dep)
!            REAL, POINTER          :: CGRID( :,:,:,: )
              REAL :: cgrid(:, :, :, :)
              INTEGER :: jdate, jtime, tstep(2)
              INTEGER :: n_spc_wdep
              INTEGER :: wdep_map(:)
              REAL :: dep(:, :, :)
            END SUBROUTINE CONVCLD_ACM
        END INTERFACE

! FIRSTIME
!-----------------------------------------------------------------------
!   begin body of subroutine  CLDPROC
!
!...Initialization
!
        IF (firstime) THEN
        LOGDEV = INIT3()
        FIRSTIME = .FALSE.

C...first check to make sure that some species in CGRID were specified
C...for output in the wet deposition array, otherwise notify the user
C...and return

        IF ( N_SPC_WDEP .LE. 0 ) THEN

          XMSG = 'No species were specified for wet deposition ' //
     &           'tracking'
          CALL M3WARN ( PNAME, JDATE, JTIME, XMSG )

          XMSG = 'ONLY CLOUD DIAGNOSTICS WILL BE WRITTEN TO THE ' //
     &           'WETDEP OUTPUT FILE!'
          CALL M3MESG ( XMSG )

        END IF

        CALL CGRID_MAP( NSPCSD, GC_STRT, AE_STRT, NR_STRT, TR_STRT )

        SPC = 0
        STRT = 1
        FINI = N_GC_WDEP
        DO VAR = STRT, FINI
          SPC = SPC + 1
          WDEP_MAP( VAR ) = GC_STRT - 1 + GC_WDEP_MAP( SPC )
        END DO

        SPC = 0
        STRT = N_GC_WDEP + 1
        FINI = N_GC_WDEP + N_AE_WDEP
        DO VAR = STRT, FINI
          SPC = SPC + 1
          WDEP_MAP( VAR ) = AE_STRT - 1 + AE_WDEP_MAP( SPC )
        END DO

        SPC = 0
        STRT = N_GC_WDEP + N_AE_WDEP + 1
        FINI = N_GC_WDEP + N_AE_WDEP + N_NR_WDEP
        DO VAR = STRT, FINI
          SPC = SPC + 1
          WDEP_MAP( VAR ) = NR_STRT - 1 + NR_WDEP_MAP( SPC )
        END DO

        SPC = 0
        STRT = N_GC_WDEP + N_AE_WDEP + N_NR_WDEP + 1
        FINI = N_GC_WDEP + N_AE_WDEP + N_NR_WDEP + N_TR_WDEP
        DO VAR = STRT, FINI
          SPC = SPC + 1
          WDEP_MAP( VAR ) = TR_STRT - 1 + TR_WDEP_MAP( SPC )
        END DO

        IF ( N_AE_SPC .GT. 0 ) THEN
C...create aerosol species pointers to distinguish micro-grams / m**3
C...  # / m**3 (number density), and m**2 / m**3 (surface area) units


           NQAE = 0       ! number of ug/m3 species
           NNAE = 0       ! number of #/m3 species
           NSAE = 0       ! number of m2/m3 species

           DO VAR = 1, N_AE_SPC
             IF ( AE_SPC( VAR )( 1:3 ) .EQ. 'NUM' ) THEN
               NNAE = NNAE + 1
               NAE( NNAE ) = AE_STRT - 1 + VAR
             ELSE IF ( AE_SPC( VAR )( 1:3 ) .EQ. 'SRF' ) THEN
               NSAE = NSAE + 1
               SAE( NSAE ) = AE_STRT - 1 + VAR
             ELSE
               NQAE = NQAE + 1
               QAE( NQAE ) = AE_STRT - 1 + VAR
             END IF
           END DO
! Allocate cgrid
          ALLOCATE(
     &        CGRID( MY_NCOLS,MY_NROWS,NLAYS,NSPCSD ),
     &        STAT = ALLOCSTAT )

C Open checkpoint file as read-only
         CALL CHK_FILE_OPEN ( ADJ_CLD_CHK, JDATE, JTIME, .FALSE. )
        END IF

C...initialize the deposition array before processing clouds

        ALLOCATE ( TOT_DEP ( MY_NCOLS,MY_NROWS,N_SPC_WDEP+1 ),
     &             STAT = ALLOCSTAT )
        IF ( ALLOCSTAT .NE. 0 ) THEN
          XMSG = 'Failure allocating TOT_DEP'
          CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
        END IF

        TOT_DEP = 0.0

        ALLOCATE ( CONV_DEP( MY_NCOLS,MY_NROWS,N_SPC_WDEP+8 ),
     &             STAT = ALLOCSTAT )
        IF ( ALLOCSTAT .NE. 0 ) THEN
          XMSG = 'Failure allocating CONV_DEP'
          CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
        END IF

        CONV_DEP = 0.0

        ALLOCATE ( DENS( MY_NCOLS,MY_NROWS,NLAYS ), STAT = ALLOCSTAT )
        IF ( ALLOCSTAT .NE. 0 ) THEN
           XMSG = 'Failure allocating DENS'
           CALL M3EXIT( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
        END IF

        CALL SUBHFILE ( MET_CRO_3D, GXOFF, GYOFF,
     &                  STRTCOLMC3, ENDCOLMC3, STRTROWMC3, ENDROWMC3 )
        END IF

      MDATE = JDATE
      MTIME = JTIME

      VNAME = 'DENS'
!
!
!     IF ( .NOT. INTERP3( MET_CRO_3D, VNAME, PNAME, MDATE, MTIME,
!    &                    NCOLS * NROWS * NLAYS, DENS ) ) THEN
        res6 = INTERPX(met_cro_3d, vname, pname, strtcolmc3, endcolmc3,
     +    strtrowmc3, endrowmc3, 1, nlays, mdate, mtime, dens)

! Read concentration checkpoint at sync step
        CALL CHK_FILE_READ ( ADJ_CLD_CHK, JDATE, JTIME, CGRID )
!slz output cgrid to check its consistency with the stand-alone cld-adj
!slz        write (*,*) "slz-chk-jdate&jtime", jdate, jtime
!slz        write (*,*) "slz-chk-cgrid", cgrid(2,4,1,76)
!slz        write (*,*) "slz-chk-cgrid", cgrid(2,4,5,75)
!slz        write (*,*) "slz-chk-cgrid", cgrid(32,21,1,76)
!slz        write (*,*) "slz-chk-cgrid", cgrid(32,21,3,2)
!slz        write (*,*) "slz-chk-cgrid", sum(cgrid)
!slz        write (*,*) "slz-chk-cgrid", maxval(cgrid),maxloc(cgrid)
!slz        write (*,*) "slz-chk-cgrid", minval(cgrid),minloc(cgrid)
!
!...convert units on cgrid to molar mixing ratio (by volume)
!...  determine no. of moles of gas per moles of air by volume
!
        strt = gc_strt
        fini = gc_strt + n_gc_spc - 1
        ad_from = strt
        DO spc=ad_from,fini
          DO lay=1,nlays
            DO row=1,my_nrows
              DO col=1,my_ncols
                IF (cgrid(col, row, lay, spc)*1.0e-6 .LT. 1.0e-30) THEN
                  cgrid(col, row, lay, spc) = 1.0e-30
                  CALL PUSHINTEGER4(2)
                ELSE
                  cgrid(col, row, lay, spc) = cgrid(col, row, lay, spc)*1.0e-6
                  CALL PUSHINTEGER4(1)
                END IF
              END DO
            END DO
          END DO
        END DO
        CALL PUSHINTEGER4(spc - 1)
        CALL PUSHINTEGER4(ad_from)
!
!...for aerosol mass concentration
!...  convert to moles of aerosol per mole of air by volume
!
        strt = 1
        fini = nqae
        ad_from0 = strt
        DO var=ad_from0,fini
          CALL PUSHINTEGER4(spc)
          spc = qae(var)
          DO lay=1,nlays
            DO row=1,my_nrows
              DO col=1,my_ncols
                CALL PUSHREAL4(fac)
                fac = cnv1/dens(col, row, lay)/ae_molwt(spc-ae_strt+1)
                IF (cgrid(col, row, lay, spc) .LT. 1.0e-30/fac) THEN
                  CALL PUSHINTEGER4(0)
                  ccmin = 1.0e-30/fac
                ELSE
                  ccmin = cgrid(col, row, lay, spc)
                  CALL PUSHINTEGER4(1)
                END IF
                cgrid(col, row, lay, spc) = fac*ccmin
              END DO
            END DO
          END DO
        END DO
        CALL PUSHINTEGER4(var - 1)
        CALL PUSHINTEGER4(ad_from0)
!
!...for aerosol number concentration
!...    convert to # per mole of air by volume
!
        strt = 1
        fini = nnae
        ad_from1 = strt
        DO var=ad_from1,fini
          CALL PUSHINTEGER4(spc)
          spc = nae(var)
          DO lay=1,nlays
            DO row=1,my_nrows
              DO col=1,my_ncols
                CALL PUSHREAL4(fac)
!             CGRID( COL, ROW, LAY, SPC ) = CGRID( COL, ROW, LAY, SPC )
!    &                                    * MWAIR / ( 1000.0
!    &                                    * DENS( COL, ROW, LAY ) )
                fac = cnv3/dens(col, row, lay)
                IF (cgrid(col, row, lay, spc) .LT. 1.0e-30/fac) THEN
                  CALL PUSHINTEGER4(0)
                  ccmin = 1.0e-30/fac
                ELSE
                  ccmin = cgrid(col, row, lay, spc)
                  CALL PUSHINTEGER4(1)
                END IF
                cgrid(col, row, lay, spc) = fac*ccmin
              END DO
            END DO
          END DO
        END DO
        CALL PUSHINTEGER4(var - 1)
        CALL PUSHINTEGER4(ad_from1)
!
!...for aerosol surface area
!...    convert to m2 per mole of air by volume
!
        strt = 1
        fini = nsae
        ad_from2 = strt
        DO var=ad_from2,fini
          CALL PUSHINTEGER4(spc)
          spc = sae(var)
          DO lay=1,nlays
            DO row=1,my_nrows
              DO col=1,my_ncols
                CALL PUSHREAL4(fac)
                fac = cnv2/dens(col, row, lay)
                IF (cgrid(col, row, lay, spc) .LT. 1.0e-30/fac) THEN
                  CALL PUSHINTEGER4(0)
                  ccmin = 1.0e-30/fac
                ELSE
                  ccmin = cgrid(col, row, lay, spc)
                  CALL PUSHINTEGER4(1)
                END IF
                cgrid(col, row, lay, spc) = fac*ccmin
              END DO
            END DO
          END DO
        END DO
        CALL PUSHINTEGER4(var - 1)
        CALL PUSHINTEGER4(ad_from2)
!
!...determine no. of moles of non-reactive gas per moles of air by volume
!
        strt = nr_strt
        fini = nr_strt + n_nr_spc - 1
        ad_from3 = strt
        CALL PUSHINTEGER4(spc)
        DO spc=ad_from3,fini
          DO lay=1,nlays
            DO row=1,my_nrows
              DO col=1,my_ncols
                IF (cgrid(col, row, lay, spc)*1.0e-6 .LT. 1.0e-30) THEN
                  cgrid(col, row, lay, spc) = 1.0e-30
                  CALL PUSHINTEGER4(2)
                ELSE
                  cgrid(col, row, lay, spc) = cgrid(col, row, lay, spc)*1.0e-6
                  CALL PUSHINTEGER4(1)
                END IF
              END DO
            END DO
          END DO
        END DO
        CALL PUSHINTEGER4(spc - 1)
        CALL PUSHINTEGER4(ad_from3)
!
!...determine no. of moles of tracer gas per moles of air by volume
!
        strt = tr_strt
        fini = tr_strt + n_tr_spc - 1
        ad_from4 = strt
        DO spc=ad_from4,fini
          DO lay=1,nlays
            DO row=1,my_nrows
              DO col=1,my_ncols
                IF (cgrid(col, row, lay, spc)*1.0e-6 .LT. 1.0e-30) THEN
                  cgrid(col, row, lay, spc) = 1.0e-30
                  CALL PUSHINTEGER4(2)
                ELSE
                  cgrid(col, row, lay, spc) = cgrid(col, row, lay, spc)*1.0e-6
                  CALL PUSHINTEGER4(1)
                END IF
              END DO
            END DO
          END DO
        END DO
        CALL PUSHINTEGER4(spc - 1)
        CALL PUSHINTEGER4(ad_from4)
        CALL PUSHINTEGER4(nspcsd)
        CALL PUSHINTEGER4(gc_strt)
        CALL PUSHINTEGER4(ae_strt)
        CALL PUSHINTEGER4(nr_strt)
        CALL PUSHINTEGER4(tr_strt)
        CALL PUSHINTEGER4ARRAY(tstep, 2)
        CALL PUSHREAL4ARRAY(cgrid, my_ncols*my_nrows*nlays*nspcsd)
        CALL RESCLD(cgrid, jdate, jtime, tstep, n_spc_wdep, wdep_map,
     +           tot_dep)
!
!...compute cloud effects for the resolved clouds and resolved rainwater
!
        CALL PUSHINTEGER4(nspcsd)
        CALL PUSHINTEGER4(gc_strt)
        CALL PUSHINTEGER4(ae_strt)
        CALL PUSHINTEGER4(nr_strt)
        CALL PUSHINTEGER4(tr_strt)
        CALL PUSHINTEGER4ARRAY(tstep, 2)
        CALL PUSHINTEGER4(jtime)
        CALL PUSHINTEGER4(jdate)
        CALL PUSHREAL4ARRAY(cgrid, my_ncols*my_nrows*nlays*nspcsd)
        CALL CONVCLD_ACM(cgrid, jdate, jtime, tstep, n_spc_wdep, wdep_map,
     +                conv_dep)
!
!...compute cloud effects for convective (subgrid) clouds
!
!
!...now check to see if it's time to write the deposition file
!
! set mdate:mtime to next tstep
!  clear MMSS fields
! time to write
! set Ndate:Ntime to next hour
!
!
!...convert units on cgrid back to original units
!...  convert to ppmV gas
!
        strt = gc_strt
        fini = gc_strt + n_gc_spc - 1
        ad_from5 = strt
        spc = fini + 1
        CALL PUSHINTEGER4(spc - 1)
        CALL PUSHINTEGER4(ad_from5)
!
!...convert to ug/m3 of aerosol mass
!
        strt = 1
        fini = nqae
        ad_from6 = strt
        DO var=ad_from6,fini
          CALL PUSHINTEGER4(spc)
          spc = qae(var)
          DO lay=1,nlays
            DO row=1,my_nrows
              DO col=1,my_ncols
                CALL PUSHREAL4(fac)
              END DO
            END DO
          END DO
        END DO
        CALL PUSHINTEGER4(var - 1)
        CALL PUSHINTEGER4(ad_from6)
!
!...convert to #/m3 of aerosol number
!
        strt = 1
        fini = nnae
        ad_from7 = strt
        DO var=ad_from7,fini
          CALL PUSHINTEGER4(spc)
          spc = nae(var)
          DO lay=1,nlays
            DO row=1,my_nrows
              DO col=1,my_ncols
                CALL PUSHREAL4(fac)
!             CGRID( COL, ROW, LAY, SPC ) = CGRID( COL, ROW, LAY, SPC )
!    &                                    * DENS( COL, ROW, LAY )
!    &                                    * 1000.0 / MWAIR
              END DO
            END DO
          END DO
        END DO
        CALL PUSHINTEGER4(var - 1)
        CALL PUSHINTEGER4(ad_from7)
!
!...convert to m2/m3 of aerosol surface area
!
        strt = 1
        fini = nsae
        ad_from8 = strt
        DO var=ad_from8,fini
          CALL PUSHINTEGER4(spc)
          spc = sae(var)
          DO lay=1,nlays
            DO row=1,my_nrows
              DO col=1,my_ncols
                CALL PUSHREAL4(fac)
              END DO
            END DO
          END DO
        END DO
        CALL PUSHINTEGER4(var - 1)
        CALL PUSHINTEGER4(ad_from8)
!
!...convert to ppmV non-reactive gas
!
        strt = nr_strt
        fini = nr_strt + n_nr_spc - 1
        ad_from9 = strt
        CALL PUSHINTEGER4(spc)
        spc = fini + 1
        CALL PUSHINTEGER4(spc - 1)
        CALL PUSHINTEGER4(ad_from9)
!
!...convert to ppmV tracer gas
!
!slz adjoint
        strt = tr_strt
        fini = tr_strt + n_tr_spc - 1
        DO spc=fini,strt,-1
          DO lay=nlays,1,-1
            DO row=my_nrows,1,-1
              DO col=my_ncols,1,-1
                cgridb(col, row, lay, spc) = 1.0e+6*cgridb(col, row, lay, spc)
              END DO
            END DO
          END DO
        END DO
        CALL POPINTEGER4(ad_from9)
        CALL POPINTEGER4(ad_to9)
        DO spc=ad_to9,ad_from9,-1
          DO lay=nlays,1,-1
            DO row=my_nrows,1,-1
              DO col=my_ncols,1,-1
                cgridb(col, row, lay, spc) = 1.0e+6*cgridb(col, row, lay, spc)
              END DO
            END DO
          END DO
        END DO
        CALL POPINTEGER4(spc)
        CALL POPINTEGER4(ad_from8)
        CALL POPINTEGER4(ad_to8)
        DO var=ad_to8,ad_from8,-1
          DO lay=nlays,1,-1
            DO row=my_nrows,1,-1
              DO col=my_ncols,1,-1
                fac = cnv2i*dens(col, row, lay)
                cgridb(col, row, lay, spc) = fac*cgridb(col, row, lay, spc)
                CALL POPREAL4(fac)
              END DO
            END DO
          END DO
          CALL POPINTEGER4(spc)
        END DO
        CALL POPINTEGER4(ad_from7)
        CALL POPINTEGER4(ad_to7)
        DO var=ad_to7,ad_from7,-1
          DO lay=nlays,1,-1
            DO row=my_nrows,1,-1
              DO col=my_ncols,1,-1
                fac = cnv3i*dens(col, row, lay)
                cgridb(col, row, lay, spc) = fac*cgridb(col, row, lay, spc)
                CALL POPREAL4(fac)
              END DO
            END DO
          END DO
          CALL POPINTEGER4(spc)
        END DO
        CALL POPINTEGER4(ad_from6)
        CALL POPINTEGER4(ad_to6)
        DO var=ad_to6,ad_from6,-1
          DO lay=nlays,1,-1
            DO row=my_nrows,1,-1
              DO col=my_ncols,1,-1
                fac = cnv1i*dens(col, row, lay)
                cgridb(col, row, lay, spc) = fac*ae_molwt(spc-ae_strt+1)*
     +            cgridb(col, row, lay, spc)
                CALL POPREAL4(fac)
              END DO
            END DO
          END DO
          CALL POPINTEGER4(spc)
        END DO
        CALL POPINTEGER4(ad_from5)
        CALL POPINTEGER4(ad_to5)
        DO spc=ad_to5,ad_from5,-1
          DO lay=nlays,1,-1
            DO row=my_nrows,1,-1
              DO col=my_ncols,1,-1
                cgridb(col, row, lay, spc) = 1.0e+6*cgridb(col, row, lay, spc)
              END DO
            END DO
          END DO
        END DO
        CALL POPREAL4ARRAY(cgrid, my_ncols*my_nrows*nlays*nspcsd)
        CALL POPINTEGER4(jdate)
        CALL POPINTEGER4(jtime)
        CALL POPINTEGER4ARRAY(tstep, 2)
        CALL POPINTEGER4(tr_strt)
        CALL POPINTEGER4(nr_strt)
        CALL POPINTEGER4(ae_strt)
        CALL POPINTEGER4(gc_strt)
        CALL POPINTEGER4(nspcsd)

        CALL CONVCLD_ACM_B(cgrid, cgridb, jdate, jtime, tstep, n_spc_wdep,
     +               wdep_map, conv_dep)
     
        CALL POPREAL4ARRAY(cgrid, my_ncols*my_nrows*nlays*nspcsd)
        CALL POPINTEGER4ARRAY(tstep, 2)
        CALL POPINTEGER4(tr_strt)
        CALL POPINTEGER4(nr_strt)
        CALL POPINTEGER4(ae_strt)
        CALL POPINTEGER4(gc_strt)
        CALL POPINTEGER4(nspcsd)
        CALL RESCLD_B(cgrid, cgridb, jdate, jtime, tstep, n_spc_wdep, wdep_map
     +          , tot_dep)

        CALL POPINTEGER4(ad_from4)
        CALL POPINTEGER4(ad_to4)
        DO spc=ad_to4,ad_from4,-1
          DO lay=nlays,1,-1
            DO row=my_nrows,1,-1
              DO col=my_ncols,1,-1
                CALL POPINTEGER4(branch)
                IF (branch .LT. 2) THEN
                  cgridb(col, row, lay, spc) = 1.0e-6*cgridb(col, row, lay,
     +              spc)
                ELSE
                  cgridb(col, row, lay, spc) = 0.0
                END IF
              END DO
            END DO
          END DO
        END DO
        CALL POPINTEGER4(ad_from3)
        CALL POPINTEGER4(ad_to3)
        DO spc=ad_to3,ad_from3,-1
          DO lay=nlays,1,-1
            DO row=my_nrows,1,-1
              DO col=my_ncols,1,-1
                CALL POPINTEGER4(branch)
                IF (branch .LT. 2) THEN
                  cgridb(col, row, lay, spc) = 1.0e-6*cgridb(col, row, lay,
     +              spc)
                ELSE
                  cgridb(col, row, lay, spc) = 0.0
                END IF
              END DO
            END DO
          END DO
        END DO
        CALL POPINTEGER4(spc)
        CALL POPINTEGER4(ad_from2)
        CALL POPINTEGER4(ad_to2)
        DO var=ad_to2,ad_from2,-1
          DO lay=nlays,1,-1
            DO row=my_nrows,1,-1
              DO col=my_ncols,1,-1
                fac = cnv2/dens(col, row, lay)
                ccminb = fac*cgridb(col, row, lay, spc)
                cgridb(col, row, lay, spc) = 0.0
                CALL POPINTEGER4(branch)
                IF (.NOT.branch .LT. 1) cgridb(col, row, lay, spc) = cgridb(
     +              col, row, lay, spc) + ccminb
                CALL POPREAL4(fac)
              END DO
            END DO
          END DO
          CALL POPINTEGER4(spc)
        END DO
        CALL POPINTEGER4(ad_from1)
        CALL POPINTEGER4(ad_to1)
	  
        DO var=ad_to1,ad_from1,-1
          DO lay=nlays,1,-1
            DO row=my_nrows,1,-1
              DO col=my_ncols,1,-1
                fac = cnv3/dens(col, row, lay)
                ccminb = fac*cgridb(col, row, lay, spc)
                cgridb(col, row, lay, spc) = 0.0
                CALL POPINTEGER4(branch)
                IF (.NOT.branch .LT. 1) cgridb(col, row, lay, spc) = cgridb(
     +              col, row, lay, spc) + ccminb
                CALL POPREAL4(fac)
              END DO
            END DO
          END DO
          CALL POPINTEGER4(spc)
        END DO
        CALL POPINTEGER4(ad_from0)
        CALL POPINTEGER4(ad_to0)
	  
        DO var=ad_to0,ad_from0,-1
          DO lay=nlays,1,-1
            DO row=my_nrows,1,-1
              DO col=my_ncols,1,-1
                ccminb = fac*cgridb(col, row, lay, spc)
                cgridb(col, row, lay, spc) = 0.0
                CALL POPINTEGER4(branch)
                IF (.NOT.branch .LT. 1) cgridb(col, row, lay, spc) = cgridb(
     +              col, row, lay, spc) + ccminb
		    CALL POPREAL4(fac)
              END DO
            END DO
          END DO
          CALL POPINTEGER4(spc)
        END DO
	  
        CALL POPINTEGER4(ad_from)
        CALL POPINTEGER4(ad_to)
        DO spc=ad_to,ad_from,-1
          DO lay=nlays,1,-1
            DO row=my_nrows,1,-1
              DO col=my_ncols,1,-1
                CALL POPINTEGER4(branch)
                IF (branch .LT. 2) THEN
                  cgridb(col, row, lay, spc) = 1.0e-6*cgridb(col, row, lay,
     +              spc)
                ELSE
                  cgridb(col, row, lay, spc) = 0.0
                END IF
              END DO
            END DO
          END DO
        END DO
	  
      END SUBROUTINE CLDPROC_BWD
