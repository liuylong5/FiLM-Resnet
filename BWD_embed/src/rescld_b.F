!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.4 (r3376) - 10 Feb 2010 17:51
!
!  Differentiation of rescld in reverse (adjoint) mode:
!   gradient     of useful results: cgrid
!   with respect to varying inputs: metstep cgrid
!
!***********************************************************************
!   Portions of Models-3/CMAQ software were developed or based on      *
!   information from various groups: Federal Government employees,     *
!   contractors working on a United States Government contract, and    *
!   non-Federal sources (including research institutions).  These      *
!   research institutions have given the Government permission to      *
!   use, prepare derivative works, and distribute copies of their      *
!   work in Models-3/CMAQ to the public and to permit others to do     *
!   so.  EPA therefore grants similar permissions for use of the       *
!   Models-3/CMAQ software, but users are requested to provide copies  *
!   of derivative works to the Government without restrictions as to   *
!   use by others.  Users are responsible for acquiring their own      *
!   copies of commercial software associated with Models-3/CMAQ and    *
!   for complying with vendor requirements.  Software copyrights by    *
!   the MCNC Environmental Modeling Center are used with their         *
!   permissions subject to the above restrictions.                     *
!***********************************************************************
!
! RCS file, release, date & time of last delta, author, state, [and locker]
! $Header$
!
! what( 1 ) key, module and SID; SCCS file; date and time of last delta:
! %W% %P% %G% %U%
!
!:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      SUBROUTINE RESCLD_B(cgrid, cgridb, jdate, jtime, tstep, n_spc_wdep,
     +  wdep_map, dep)
        USE GRID_CONF
        USE CGRID_SPCS
        IMPLICIT NONE

C...........Includes:
#ifdef Incl
      INCLUDE SUBST_GC_SPC               ! gas chemistry species table
      INCLUDE SUBST_AE_SPC               ! aerosol species table
      INCLUDE SUBST_NR_SPC               ! non-reactive species table
      INCLUDE SUBST_TR_SPC               ! tracer species table
#endif

      INCLUDE SUBST_CONST                ! constants
      INCLUDE SUBST_FILES_ID             ! file name parameters
      INCLUDE SUBST_IOPARMS              ! I/O parameters definitions
      INCLUDE SUBST_IOFDESC              ! file header data structuer
      INCLUDE SUBST_IODECL               ! I/O definitions and declarations

        CHARACTER(len=120) :: xmsg=' '
!
!...........Parameters:
! g/kg
        REAL, PARAMETER :: gpkg=1.0e+03
! 1 hectare = 1.0e4 m**2
        REAL, PARAMETER :: m2pha=1.0e+04
        REAL, PARAMETER :: m2pha_over_gpkg=m2pha/gpkg
!
! Number of species in CGRID
!
        INTEGER, PARAMETER :: mxspcs=n_gc_spcd+n_ae_spc+n_nr_spc+n_tr_spc
!
!
!...........Arguments:
!     REAL          CGRID( NCOLS,NROWS,NLAYS,* )  !  concentrations
! concentrations
        REAL :: cgrid(:, :, :, :)
        REAL, POINTER :: cgridb(:, :, :, :)
!      REAL, POINTER :: CGRID( :,:,:,: )    ! concentrations
! current model date, coded YYYYDDD
        INTEGER :: jdate
! current model time, coded HHMMSS
        INTEGER :: jtime
! model time step, coded H*MMSS
        INTEGER :: tstep(2)
! # of wet deposition species
        INTEGER :: n_spc_wdep
!     INTEGER       WDEP_MAP( * )       ! wet deposition map to CGRID
! wet deposition map to CGRID
        INTEGER :: wdep_map(:)
!     REAL          DEP  ( NCOLS,NROWS,* )  ! depositions (etc.)
! depositions (etc.)
        REAL :: dep(:, :, :)
!
!...........Local Variables:
!
! flag for first pass thru
        LOGICAL, SAVE :: firstime=.true.
! flag for QG available on file
        LOGICAL, SAVE :: qg_avail=.true.
! flag for QI available on file
        LOGICAL, SAVE :: qi_avail=.true.
! flag for QS available on file
        LOGICAL, SAVE :: qs_avail=.true.
!
! process name
        CHARACTER(len=16), SAVE :: pname='RESCLD_b'
! variable name for IOAPI to get
        CHARACTER(len=16) :: varnm
!
! column loop counter
        INTEGER :: col
! row loop counter
        INTEGER :: row
! layer loop counter
        INTEGER :: lay
! ending position
        INTEGER :: fini
! output log unit number
        INTEGER, SAVE :: logdev
! process date (yyyyddd)
        INTEGER :: mdate
! met file time step (hhmmss)
        INTEGER, SAVE :: mstep
! process time (hhmmss)
        INTEGER :: mtime
! met file start date
        INTEGER, SAVE :: sdate
! liquid species loop counter
        INTEGER :: spc
! starting position
        INTEGER :: strt
! met file start time
        INTEGER, SAVE :: stime
! cloud lifetime (sec)
        INTEGER :: tcld
! variable loop counter
        INTEGER :: var
! memory allocation status
        INTEGER :: allocstat
!
! total airmass (mol/m2) in cloudy air
        REAL :: airm
! aitken mode number scavenging coef
        REAL :: alfa0
        REAL :: alfa0b
! aitken mode sfc area scavenging coef
        REAL :: alfa2
        REAL :: alfa2b
! aitken mode mass scavenging coef
        REAL :: alfa3
        REAL :: alfa3b
! cloud thickness (m)
        REAL :: cthk1
! timestep on the met file (hr)
        REAL :: metstep
        SAVE metstep
! mean cloud pressure (Pa)
        REAL :: pbarc
! storm rainfall rate (mm/hr)
        REAL :: prate1
! vert column integrated liquid water content
        REAL :: qcrgcol
! vert column integrated total water content
        REAL :: qcrisgcol
! vert column integrated precip content
        REAL :: qrsgcol
! non-conv rainfall rate (mm/hr)
        REAL :: rain
! variable storing H+ deposition
        REAL :: removac
! cloud lifetime (sec)
        REAL :: taucld
! mean cloud temp (K)
        REAL :: tbarc
! liq water content of cloud (kg/m3)
        REAL :: wcbar
! precipitation water content (kg/m3)
        REAL :: wpbar
! total water content of cloud (kg/m3)
        REAL :: wtbar
!
!
! incloud conc (mol/mol)
        REAL :: polc(mxspcs)
        REAL :: polcb(mxspcs)
! ending conc (mol/mol)
        REAL :: cend(mxspcs)
        REAL :: cendb(mxspcs)
! moles/m2 or mm*mol/lit scavenged
        REAL :: remov(mxspcs)
!
! non-convective rainfall (cm)
        REAL :: rn(ncols, nrows)
! air density (kg/m3)
        REAL :: dens(ncols, nrows, nlays)
! layer thickness (m)
        REAL :: dzz(ncols, nrows, nlays)
! air pressure (Pa)
        REAL :: pres(ncols, nrows, nlays)
! cloud water content (kg/kg)
        REAL :: qc(ncols, nrows, nlays)
! graupel content (kg/kg)
        REAL :: qg(ncols, nrows, nlays)
! ice content (kg/kg)
        REAL :: qi(ncols, nrows, nlays)
! rain water content (kg/kg)
        REAL :: qr(ncols, nrows, nlays)
! snow content (kg/kg)
        REAL :: qs(ncols, nrows, nlays)
!     REAL          QV   ( NCOLS, NROWS, NLAYS )  ! specific humidity (kg/kg)
! air temperature (K)
        REAL :: ta(ncols, nrows, nlays)
!     REAL          ZH   ( NCOLS, NROWS, NLAYS )  ! mid-layer height (m)
! level/layer-face height (m)
        REAL :: zf(ncols, nrows, nlays)
!
! global origin offset from file
        INTEGER :: gxoff, gyoff
! for INTERPX
        INTEGER, SAVE :: strtcolmc2, endcolmc2, strtrowmc2, endrowmc2
        INTEGER, SAVE :: strtcolmc3, endcolmc3, strtrowmc3, endrowmc3
!
!...........External Functions:
        LOGICAL, EXTERNAL :: CURRSTEP
        INTEGER, EXTERNAL :: SEC2TIME, secsdiff, TIME2SEC, INDEX1, TRIMLEN
        EXTERNAL SUBHFILE
        INTEGER :: result1
        LOGICAL :: result10
        LOGICAL :: res
        LOGICAL :: res0
        LOGICAL :: res1
        INTEGER :: res2
        INTEGER :: res3
        LOGICAL :: res4
        LOGICAL :: res5
        LOGICAL :: res6
        LOGICAL :: res7
        LOGICAL :: res8
        LOGICAL :: res9
        LOGICAL :: res10
        LOGICAL :: res11
        LOGICAL :: res12
        LOGICAL :: res13
        LOGICAL :: res14
        INTEGER :: branch
        INTEGER :: ad_to
        INTEGER :: ad_to0
        INTRINSIC MAX
        INTRINSIC INDEX
        INTRINSIC FLOAT
        INTRINSIC REAL
! FIRSTIME
!
!
!-----------------------------------------------------------------------
!
!...Initialization
!
        IF (firstime) THEN
        FIRSTIME = .FALSE.

        LOGDEV = INIT3()


        CALL CGRID_MAP( NSPCSD, GC_STRT, AE_STRT, NR_STRT, TR_STRT )

C...open MET_CRO_2D

        IF ( .NOT. OPEN3( MET_CRO_2D, FSREAD3, PNAME ) ) THEN
          XMSG = 'Could not open '// MET_CRO_2D // ' file'
          CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
        END IF

C...open MET_CRO_3D

        IF ( .NOT. OPEN3( MET_CRO_3D, FSREAD3, PNAME ) ) THEN
          XMSG = 'Could not open '// MET_CRO_3D // ' file'
          CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
        END IF

C...get description from the met file

        IF ( .NOT. DESC3( MET_CRO_3D ) ) THEN
          XMSG = 'Could not get ' // MET_CRO_3D //' file description'
          CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
        END IF

C...store met file time, date, and step information and compute
C...  the met timestep in hours

        SDATE = SDATE3D
        STIME = STIME3D
        MSTEP = TSTEP3D

        METSTEP = FLOAT( TIME2SEC( MSTEP ) ) / 3600.0

        VAR = INDEX1( 'QI', NVARS3D, VNAME3D )

        IF ( VAR .EQ. 0 ) THEN
          QI_AVAIL = .FALSE.
          XMSG = 'Parameter QI (cloud ice) was not found on file '
     &           // MET_CRO_3D
          CALL M3WARN ( PNAME, JDATE, JTIME, XMSG )
          WRITE( LOGDEV, '(3(/10X,A),(/10X,3(A,1X)),(/10X,A))' )
     &           'YOU SHOULD VERIFY that the cloud microphysics scheme used',
     &           'in the Meteorological Model did not include ice/snow.  If',
     &           'it did, then you need to reprocess the meteorological data',
     &           'through MCIP and pass QI to file ',
     &           MET_CRO_3D( 1:TRIMLEN( MET_CRO_3D ) ), ' to avoid',
     &           'errors in the wet deposition.'
          WRITE( LOGDEV, '((/5X,A),/)' )
     &           'Processing will continue with QI set to ZERO.  <<---<<'
        END IF

        VAR = INDEX1( 'QS', NVARS3D, VNAME3D )

        IF ( VAR .EQ. 0 ) THEN
          QS_AVAIL = .FALSE.
          XMSG = 'Parameter QS (snow) was not found on file ' // MET_CRO_3D
          CALL M3WARN ( PNAME, JDATE, JTIME, XMSG )
          WRITE( LOGDEV, '(3(/10X,A),(/10X,3(A,1X)),(/10X,A))' )
     &           'YOU SHOULD VERIFY that the cloud microphysics scheme used',
     &           'in the Meteorological Model did not include ice/snow.  If',
     &           'it did, then you need to reprocess the meteorological data',
     &           'through MCIP and pass QS to file ',
     &           MET_CRO_3D( 1:TRIMLEN( MET_CRO_3D ) ), ' to avoid',
     &           'errors in the wet deposition.'
          WRITE( LOGDEV, '((/5X,A),/)' )
     &           'Processing will continue with QS set to ZERO.  <<--<<'
        END IF

        VAR = INDEX1( 'QG', NVARS3D, VNAME3D )

        IF ( VAR .EQ. 0 ) THEN
          QG_AVAIL = .FALSE.
        END IF

        CALL SUBHFILE ( MET_CRO_2D, GXOFF, GYOFF,
     &                  STRTCOLMC2, ENDCOLMC2, STRTROWMC2, ENDROWMC2 )
        CALL SUBHFILE ( MET_CRO_3D, GXOFF, GYOFF,
     &                  STRTCOLMC3, ENDCOLMC3, STRTROWMC3, ENDROWMC3 )

        END IF

      MDATE = JDATE
      MTIME = JTIME

C...set the cloud lifetime (=adv timestep)

      TCLD = TIME2SEC( TSTEP( 2 ) )
      TAUCLD = REAL( TCLD )

C...set time to the midpoint of this timestep for data interpolation

      CALL NEXTIME ( MDATE, MTIME, SEC2TIME( TCLD / 2 ) )

C...Actual Science Process (loop on internal process time steps):
C...  Interpolate time dependent layered input variables
C...  (reading those variables for which it is necessary)

C...  Get ambient temperature (K)

      VARNM = 'TA'
!     IF ( .NOT. INTERP3( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                    NCOLS * NROWS * NLAYS, TA ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MDATE, MTIME, TA ) ) THEN
        XMSG = 'Could not read TA from ' // MET_CRO_3D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
      END IF

C...Get resolved cloud water mixing ratio (kg H2O / kg air)

      VARNM = 'QC'
!     IF ( .NOT. INTERP3( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                    NCOLS * NROWS * NLAYS, QC ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MDATE, MTIME, QC ) ) THEN
        XMSG = 'Could not read QC from ' // MET_CRO_3D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
      END IF

C...Get resolved rain water mixing ratio (kg H2O / kg air)

      VARNM = 'QR'
!     IF ( .NOT. INTERP3( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                    NCOLS * NROWS * NLAYS, QR ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MDATE, MTIME, QR ) ) THEN
        XMSG = 'Could not read QR from ' // MET_CRO_3D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
      END IF

C...read resolved ice mixing ratio (kg H2O / kg air) from the met
C...  file if it is available

      IF ( QI_AVAIL ) THEN

        VARNM = 'QI'
!       IF ( .NOT. INTERP3( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                      NCOLS * NROWS * NLAYS, QI ) ) THEN
          XMSG = 'Could not read QI from ' // MET_CRO_3D
        IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                      STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                      MDATE, MTIME, QI ) ) THEN
          CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
        END IF

      ELSE

        QI = 0.0    ! otherwise fill the array with zeros

      END IF

C...read resolved snow mixing ratio (kg H2O / kg air) from the met
C...  file if it is available

      IF ( QS_AVAIL ) THEN

        VARNM = 'QS'
!       IF ( .NOT. INTERP3( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                      NCOLS * NROWS * NLAYS, QS ) ) THEN
        IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                      STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                      MDATE, MTIME, QS ) ) THEN
          XMSG = 'Could not read QS from ' // MET_CRO_3D
          CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
        END IF

      ELSE

        QS = 0.0    ! otherwise fill the array with zeros

      END IF

C...read graupel mixing ratio (kg H2O / kg air) from the met
C...  file if it is available

      IF ( QG_AVAIL ) THEN

        VARNM = 'QG'
!       IF ( .NOT. INTERP3( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                      NCOLS * NROWS * NLAYS, QG ) ) THEN
          XMSG = 'Could not read QG from ' // MET_CRO_3D
        IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                      STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                      MDATE, MTIME, QG ) ) THEN
          CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
        END IF

      ELSE

        QG = 0.0    ! otherwise fill the array with zeros

      END IF

!C...Get specific humidity (kg H2O / kg air)
 
!     VARNM = 'QV'
!!    IF ( .NOT. INTERP3( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!!   &                    NCOLS * NROWS * NLAYS, QV ) ) THEN
!     IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
!    &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
!    &                    MDATE, MTIME, QV ) ) THEN
!       XMSG = 'Could not read QV from ' // MET_CRO_3D
!       CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!     END IF
 
C...Get level heights / layer faces (m)

      VARNM = 'ZF'
!     IF ( .NOT. INTERP3 ( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                     NCOLS * NROWS * NLAYS, ZF ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MDATE, MTIME, ZF ) ) THEN
        XMSG = 'Could not read ZF from ' // MET_CRO_3D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
      END IF

!C...Get mid-layer heights (m)
!
!     VARNM = 'ZH'
!!    IF ( .NOT. INTERP3 ( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!!   &                     NCOLS * NROWS * NLAYS, ZH ) ) THEN
!     IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
!    &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
!    &                    MDATE, MTIME, ZH ) ) THEN
!       XMSG = 'Could not read ZH from ' // MET_CRO_3D
!       CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
!     END IF
 
C...Get pressure (Pa)

      VARNM = 'PRES'
!     IF ( .NOT. INTERP3( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                    NCOLS * NROWS * NLAYS, PRES ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MDATE, MTIME, PRES ) ) THEN
        XMSG = 'Could not read PRES from ' // MET_CRO_3D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
      END IF

C...Get air density (kg/m3)

      VARNM = 'DENS'
!     IF ( .NOT. INTERP3( MET_CRO_3D, VARNM, PNAME, MDATE, MTIME,
!    &                    NCOLS * NROWS * NLAYS, DENS ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_3D, VARNM, PNAME,
     &                    STRTCOLMC3,ENDCOLMC3, STRTROWMC3,ENDROWMC3, 1,NLAYS,
     &                    MDATE, MTIME, DENS ) ) THEN
        XMSG = 'Could not read DENS from ' // MET_CRO_3D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
      END IF

C...compute layer thicknesses (m)

      DO ROW = 1, MY_NROWS
        DO COL = 1, MY_NCOLS
          DZZ( COL, ROW, 1 ) = ZF( COL, ROW, 1 )
          DO LAY = 2, NLAYS
            DZZ( COL, ROW, LAY ) = ZF( COL, ROW, LAY )
     &                           - ZF( COL, ROW, LAY - 1 )
          END DO
        END DO
      END DO

C...advance the MDATE and MTIME to the next time on the met file
C...  to get ready to read the precipitation amounts.
C...  Precipitation data WILL NOT BE INTERPOLATED!  Precipitation data
C...  on the input file are amounts within the metfiles timestep.

      IF ( .NOT. CURRSTEP( JDATE, JTIME, SDATE, STIME, MSTEP,
     &                     MDATE, MTIME ) ) THEN
        XMSG = 'Cannot get step-starting date and time'
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT3 )
      END IF

      CALL NEXTIME ( MDATE, MTIME, MSTEP )  ! set mdate:mtime to the hour

C...Get nonconvective precipitation amount (cm)

      VARNM = 'RN'
!     IF ( .NOT. READ3( MET_CRO_2D, VARNM, ALLAYS3, MDATE, MTIME,
!    &                  RN ) ) THEN
      IF ( .NOT. INTERPX( MET_CRO_2D, VARNM, PNAME,
     &                    STRTCOLMC2,ENDCOLMC2, STRTROWMC2,ENDROWMC2, 1,1,
     &                    MDATE, MTIME, RN ) ) THEN
        XMSG = 'Could not read RN from ' // MET_CRO_2D
        CALL M3EXIT ( PNAME, JDATE, JTIME, XMSG, XSTAT1 )
      END IF
!
!...Loop through all grid cells
!
        DO row=1,my_nrows
          DO col=1,my_ncols
!
!...Convert the rainfall into a rainfall rate (mm/hr)
!
            rain = 10.0*rn(col, row)/metstep
!
!
!...calculate the integrated column cloud+rain water content
!... JP & SJR:  treat graupel as rainwater until we have a more
!...            advanced cloud microphysics scheme
!... include layer thickness in the column integration
!
            qcrgcol = 0.0
            qcrisgcol = 0.0
            qrsgcol = 0.0
            DO lay=1,nlays
              IF (qc(col, row, lay) .LT. 0.0) THEN
                qc(col, row, lay) = 0.0
              ELSE
                qc(col, row, lay) = qc(col, row, lay)
              END IF
              IF (qr(col, row, lay) .LT. 0.0) THEN
                qr(col, row, lay) = 0.0
              ELSE
                qr(col, row, lay) = qr(col, row, lay)
              END IF
              IF (qi(col, row, lay) .LT. 0.0) THEN
                qi(col, row, lay) = 0.0
              ELSE
                qi(col, row, lay) = qi(col, row, lay)
              END IF
              IF (qs(col, row, lay) .LT. 0.0) THEN
                qs(col, row, lay) = 0.0
              ELSE
                qs(col, row, lay) = qs(col, row, lay)
              END IF
              IF (qg(col, row, lay) .LT. 0.0) THEN
                qg(col, row, lay) = 0.0
              ELSE
                qg(col, row, lay) = qg(col, row, lay)
              END IF
              qcrgcol = qcrgcol + dens(col, row, lay)*dzz(col, row, lay)*(qc(
     +          col, row, lay)+qr(col, row, lay)+qg(col, row, lay))
              qcrisgcol = qcrisgcol + dens(col, row, lay)*dzz(col, row, lay)*(
     +          qc(col, row, lay)+qr(col, row, lay)+qi(col, row, lay)+qs(col,
     +          row, lay)+qg(col, row, lay))
              qrsgcol = qrsgcol + dens(col, row, lay)*dzz(col, row, lay)*(qr(
     +          col, row, lay)+qs(col, row, lay)+qg(col, row, lay))
            END DO
!
!...loop through layers
!
            IF (qcrgcol .GT. 0.0) THEN
              DO lay=1,nlays
!
!...Compute cloud quantities
!
                IF (qc(col, row, lay) + qr(col, row, lay) + qg(col, row, lay)
     +              .GT. 0.00005) THEN
                  CALL PUSHREAL4(tbarc)
!
                  tbarc = ta(col, row, lay)
                  CALL PUSHREAL4(pbarc)
!
                  pbarc = pres(col, row, lay)
                  CALL PUSHREAL4(cthk1)
!
                  cthk1 = dzz(col, row, lay)
                  CALL PUSHREAL4(airm)
!
                  airm = pbarc*cthk1*1.0e3/(rdgas*mwair*tbarc)
                  CALL PUSHREAL4(wcbar)
!
                  wcbar = (qc(col, row, lay)+qr(col, row, lay)+qg(col, row,
     +              lay))*dens(col, row, lay)
                  CALL PUSHREAL4(wtbar)
!
                  wtbar = (qc(col, row, lay)+qr(col, row, lay)+qi(col, row,
     +              lay)+qs(col, row, lay)+qg(col, row, lay))*dens(col, row,
     +              lay)
!
!...Compute precipitation flux
!...  include layer thickness in the calculation
!
                  IF (qrsgcol .GT. 0.0) THEN
                    wpbar = (qr(col, row, lay)+qs(col, row, lay)+qg(col, row,
     +                lay))*dens(col, row, lay)
                    CALL PUSHREAL4(prate1)
! convert to mm/hr
                    prate1 = rain*wpbar*cthk1/qrsgcol
                    CALL PUSHINTEGER4(0)
                  ELSE
                    CALL PUSHREAL4(prate1)
! convert to mm/hr
                    prate1 = rain*wtbar*cthk1/qcrisgcol
                    CALL PUSHINTEGER4(1)
                  END IF
!
!...Finally, get in-cloud pollutant concentrations in moles sp
!...  per mole air
!
                  DO spc=1,nspcsd
                    CALL PUSHREAL4(polc(spc))
                    polc(spc) = cgrid(col, row, lay, spc)
                    cend(spc) = polc(spc)
                  END DO
                  CALL PUSHINTEGER4(spc - 1)
                  CALL PUSHINTEGER4(gc_strt)
                  CALL PUSHINTEGER4(ae_strt)
                  CALL PUSHINTEGER4(nr_strt)
                  CALL PUSHINTEGER4(tr_strt)
                  CALL PUSHREAL4(alfa3)
                  CALL PUSHREAL4(alfa2)
                  CALL PUSHREAL4(alfa0)
                  CALL SCAVWDEP(jdate, jtime, wtbar, wcbar, tbarc, pbarc,
     +                       cthk1, airm, prate1, taucld, polc, cend, remov,
     +                       removac, alfa0, alfa2, alfa3)
!
!...perform scavenging and aqueous chemistry within the cloud
!...  and re-adjust the ending and removed amounts for those species
!...  that were scavenged or that participated in cloud chemistry
!
!
!...if the liquid water content is above the specified threshold
!...  then perform the aqueous chemistry within the cloud and
!...  re-adjust the ending and removed amounts for those species
!...  that participated in cloud chemistry
!
                  IF (wcbar .GT. 0.00001) THEN
                    CALL PUSHINTEGER4(gc_strt)
                    CALL PUSHINTEGER4(ae_strt)
                    CALL PUSHINTEGER4(nr_strt)
                    CALL PUSHINTEGER4(tr_strt)
                    CALL PUSHREAL4ARRAY(cend, 137)
                    CALL AQ_MAP(jdate, jtime, wtbar, wcbar, tbarc, pbarc,
     +                       cthk1, airm, prate1, taucld, polc, cend, remov,
     +                       removac, alfa0, alfa2, alfa3)
                    CALL PUSHINTEGER4(1)
                  ELSE
                    CALL PUSHINTEGER4(0)
                  END IF
!
!...set cgrid to the ending concentrations
!
                  DO spc=1,nspcsd
                    IF (spc .NE. n_gc_spcd) THEN
                      CALL PUSHINTEGER4(3)
                    ELSE
                      CALL PUSHINTEGER4(2)
                    END IF
                  END DO
                  CALL PUSHINTEGER4(spc - 1)
                  CALL PUSHINTEGER4(2)
                ELSE
                  CALL PUSHINTEGER4(1)
                END IF
              END DO
              CALL PUSHINTEGER4(2)
            ELSE
              CALL PUSHINTEGER4(1)
            END IF
          END DO
        END DO
        polcb = 0.0
        alfa0b = 0.0
        alfa2b = 0.0
        alfa3b = 0.0
        cendb = 0.0
        DO row=my_nrows,1,-1
          DO col=my_ncols,1,-1
            CALL POPINTEGER4(branch)
            IF (.NOT.branch .LT. 2) THEN
              DO lay=nlays,1,-1
                CALL POPINTEGER4(branch)
                IF (.NOT.branch .LT. 2) THEN
                  CALL POPINTEGER4(ad_to0)
                  DO spc=ad_to0,1,-1
                    CALL POPINTEGER4(branch)
                    IF (.NOT.branch .LT. 3) THEN
                      cendb(spc) = cendb(spc) + cgridb(col, row, lay, spc)
                      cgridb(col, row, lay, spc) = 0.0
                    END IF
                  END DO
                  CALL POPINTEGER4(branch)
                  IF (.NOT.branch .LT. 1) THEN
                    tbarc = ta(col, row, lay)
                    pbarc = pres(col, row, lay)
                    cthk1 = dzz(col, row, lay)
                    airm = pbarc*cthk1*1.0e3/(rdgas*mwair*tbarc)
                    CALL POPREAL4ARRAY(cend, 137)
                    CALL POPINTEGER4(tr_strt)
                    CALL POPINTEGER4(nr_strt)
                    CALL POPINTEGER4(ae_strt)
                    CALL POPINTEGER4(gc_strt)
                    CALL AQ_MAP_B(jdate, jtime, wtbar, wcbar, tbarc, pbarc,
     +                      cthk1, airm, prate1, taucld, polc, polcb, cend,
     +                      cendb, remov, removac, alfa0, alfa0b, alfa2,
     +                      alfa2b, alfa3, alfa3b)
                  END IF
                  CALL POPREAL4(alfa0)
                  CALL POPREAL4(alfa2)
                  CALL POPREAL4(alfa3)
                  CALL POPINTEGER4(tr_strt)
                  CALL POPINTEGER4(nr_strt)
                  CALL POPINTEGER4(ae_strt)
                  CALL POPINTEGER4(gc_strt)
                  CALL SCAVWDEP_B(jdate, jtime, wtbar, wcbar, tbarc, pbarc,
     +                      cthk1, airm, prate1, taucld, polc, polcb, cend,
     +                      cendb, remov, removac, alfa0, alfa0b, alfa2,
     +                      alfa2b, alfa3, alfa3b)
                  CALL POPINTEGER4(ad_to)
                  DO spc=ad_to,1,-1
                    polcb(spc) = polcb(spc) + cendb(spc)
                    cendb(spc) = 0.0
                    CALL POPREAL4(polc(spc))
                    cgridb(col, row, lay, spc) = cgridb(col, row, lay, spc) +
     +                polcb(spc)
                    polcb(spc) = 0.0
                  END DO
                  CALL POPINTEGER4(branch)
                  IF (branch .LT. 1) THEN
                    CALL POPREAL4(prate1)
                  ELSE
                    CALL POPREAL4(prate1)
                  END IF
                  CALL POPREAL4(wtbar)
                  CALL POPREAL4(wcbar)
                  CALL POPREAL4(airm)
                  CALL POPREAL4(cthk1)
                  CALL POPREAL4(pbarc)
                  CALL POPREAL4(tbarc)
                END IF
              END DO
            END IF
          END DO
        END DO
      END SUBROUTINE RESCLD_B
